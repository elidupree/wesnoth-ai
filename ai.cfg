[ai]
  version=1071034
  [engine]
    name="lua"
    code= <<
--! ==============================================================
helper = wesnoth.require("lua/helper.lua")

local builtin_ai_stuff = ...
local our_ai = { }
--local ai_stdlib = wesnoth.require('ai/lua/stdlib.lua')
--ai_stdlib.init(builtin_ai_funcs)

local function naive_deep_copy(table)
  local output = {}
  for k,v in pairs(table) do
    if type(v) == "table" then output[k] = naive_deep_copy(v)
    else output[k] = v end
  end
  return output
end

local get_locations = function(filter)
  local result = wesnoth.get_locations(filter)
  for i,entry in ipairs(result) do
    entry.x = entry[1]
    entry.y = entry[2]
  end
  return result
end

local latest_info = function(plan, unit, after_this_index)
  after_this_index = after_this_index or table.getn(plan)
  local result = wesnoth.copy_unit(unit)
  local i = 1
  while i <= after_this_index do
    local action = plan[after_this_index]
    if action.uid == unit.__cfg.underlying_id and (action.type == "move" or action.type == "move_and_attack") then
      local path, cost = wesnoth.find_path(result, action.dst.x, action.dst.y)
      result.x = action.dst.x
      result.y = action.dst.y
      result.moves = result.moves - cost
    end
    i = i + 1
  end
  return result
end

local can_reach = function(plan, unit, dst, after_this_index)
  after_this_index = after_this_index or table.getn(plan)
  local path, cost = wesnoth.find_path(unit, dst.x, dst.y, { max_cost = unit.moves })
  -- TODO what's the actual return value if there's no path
  if path and cost and cost <= unit.moves then
    return true
  end
  return false
end


local plan_with_random_change = function(our_ai, plan)
  
  local added_action_choices = {}
  for i,unit in ipairs(our_ai.our_units) do
    local updated = latest_info(plan, unit)
    local src = { x = updated.x, y = updated.y }
    local dsts = get_locations({
      x = updated.x,
      y = updated.y,
      radius = updated.moves
    })
    for i,dst in ipairs(dsts) do
      if can_reach(plan, updated, dst) then
        local attack_type = "attack"
        if dst.x ~= updated.x or dst.y ~= updated.y then
          table.insert(added_action_choices, { type = "move", uid = unit.__cfg.underlying_id, src = src, dst = dst })
          attack_type = "move_and_attack"
        end
        
        local maybe_attackables = wesnoth.get_units({
          { "filter_location", {
            x = dst.x,
            y = dst.y,
            radius = 1
          }}
        })
        for i,maybe_attackable in ipairs(maybe_attackables) do
          if wesnoth.is_enemy(unit.side, maybe_attackable.side) then
            --for each weapon "weapon" the unit has do
              table.insert(added_action_choices, { type = attack_type, uid = unit.__cfg.underlying_id, src = src, dst = dst, attack = { uid = maybe_attackable.__cfg.underlying_id, x = maybe_attackable.x, y = maybe_attackable.y, weapon = 0 }})
            --end
          end
        end
      end
    end
  end
  
  local new_plan = naive_deep_copy(plan)
  
  local choice = math.random(table.getn(added_action_choices) + table.getn(plan))
  if added_action_choices[choice] then table.insert(new_plan, added_action_choices[choice])
  else table.remove(new_plan, table.getn(added_action_choices)) end
  return new_plan
end

function random_hp_amount(stats)
  local which = math.random(100)
  for hp,chance in ipairs(stats.hp_amount) do
    which = which - chance
    if which <= 0 then return hp end
  end
  wesnoth.message("Whoops")
  return 1
end

function simulate_plan(plan)
  local units = wesnoth.get_units({})
  local id_index = {}
  local result = { units = units, villages_captured = {} }
  for i,unit in ipairs(units) do
    units[i] = wesnoth.copy_unit(unit)
    id_index[unit.__cfg.underlying_id] = i
  end
  for i,action in ipairs(plan) do
    local unit = units[id_index[action.uid]]
    if action.type == "move" or action.type == "move_and_attack" then
      unit.x = action.dst.x
      unit.y = action.dst.y
      -- hack - not doing movecost yet
      local vil_owner = wesnoth.get_village_owner(unit.x, unit.y)
      if (not vil_owner) or wesnoth.is_enemy(vil_owner, builtin_ai_stuff.side) then
        if not result.villages_captured[unit.x] then result.villages_captured[unit.x] = {} end
        if not result.villages_captured[unit.x][unit.y] then result.villages_captured[unit.x][unit.y] = true end
      end
    end
    if action.type == "attack" or action.type == "move_and_attack" then
      local real_enemy = wesnoth.get_unit(action.attack.x, action.attack.y)
      if real_enemy then
        local modified_enemy = units[id_index[action.attack.uid]]
        local att_stats, def_stats = wesnoth.simulate_combat(unit, action.attack.weapon, real_enemy)
      
        local new_def_hp = random_hp_amount(def_stats)
        modified_enemy.hitpoints = math.max(0, modified_enemy.hitpoints - (real_enemy.hitpoints - new_def_hp))
        -- a unit can only attack once, so we don't need to consider it specially
        unit.hitpoints = random_hp_amount(att_stats)
      end
    end
  end
  return result
end

function evaluate_plan(plan)
  local new_state = simulate_plan(plan)
  local evaluation = 0
  for i,unit in ipairs(new_state.units) do
    if unit.hitpoints > 0 then
      local unit_value = unit.hitpoints + unit.max_hitpoints
      if wesnoth.is_enemy(unit.side, builtin_ai_stuff.side) then
        evaluation = evaluation - unit_value
      end
    end
  end
  for i,column in ipairs(new_state.villages_captured) do
    for i,v in ipairs(column) do
      evaluation = evaluation + 10
    end
  end
  return evaluation
end

function our_ai:do_moves()
  self.our_units = wesnoth.get_units({ side = builtin_ai_stuff.side })
  
  local current_plan = {}
  local current_eval = evaluate_plan(current_plan)
  
  local max_countdown = 100000
  self.countdown = max_countdown
  
  while self.countdown > 0 do
    self.countdown = self.countdown - 100
    local new_plan = plan_with_random_change(self, current_plan)
    local new_eval = evaluate_plan(new_plan)
    if (new_eval > current_eval) or math.random() < (self.countdown / max_countdown) then
      current_plan = new_plan
      current_eval = new_eval
    end
  end
  
  for i,action in ipairs(current_plan) do
    if action.type == "move" or action.type == "move_and_attack" then
      builtin_ai_stuff.move(action.src.x, action.src.y, action.dst.x, action.dst.y)
    end
    if action.type == "attack" or action.type == "move_and_attack" then
      if wesnoth.get_unit(action.attack.x, action.attack.y) then
        builtin_ai_stuff.attack(action.dst.x, action.dst.y, action.attack.x, action.attack.y, action.attack.weapon)
      end
    end
  end
  
  local units = wesnoth.get_units({ side = builtin_ai_stuff.side })
  for i,unit in ipairs(units) do
    builtin_ai_stuff.move_full(unit.x, unit.y, unit.x, unit.y)
  end
end

return our_ai
--! ==============================================================
>>
  [/engine]
  [stage]
    engine="lua"
    code="(...):do_moves()"
  [/stage]
[/ai]

