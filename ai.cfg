[ai]
  version=10710
  [engine]
    name="lua"
    code= <<
--! ==============================================================
helper = wesnoth.require("lua/helper.lua")

local builtin_ai_stuff = ...
local our_ai = { }
local ai_stdlib = wesnoth.require('ai/lua/stdlib.lua')
ai_stdlib.init(builtin_ai_funcs)

local function naive_deep_copy(table)
  local output = {}
  for k,v in pairs(table) do
    if type(v) == "table" then output[k] = naive_deep_copy(v)
    else output[k] = v end
  end
  return output
end

local get_locations_xy = function(filter)
  local result = wesnoth.get_locations(filter)
  for i,entry in ipairs(result) do
    result.x = result[1]
    result.y = result[2]
  end
end

local latest_info = function(plan, unit, after_this_index)
  after_this_index = after_this_index or table.getn(plan)
  local result = naive_deep_copy(unit)
  local i = 1
  while i <= after_this_index do
    local action = plan[after_this_index]
    if action.uid == unit.underlying_id and (action.type == "move" or action.type == "move_and_attack") then
      local path, cost = wesnoth.find_path(result, action.dst.x, action.dst.y)
      result.x = action.dst.x
      result.y = action.dst.y
      result.moves = result.moves - cost
    end
    i = i + 1
  end
  return result
end

local can_reach = function(plan, unit, destination, after_this_index)
  after_this_index = after_this_index or table.getn(plan)
  local path, cost = wesnoth.find_path(unit, destination.x, destination.y, { max_cost = unit.moves })
  -- TODO what's the actual return value if there's no path
  if path and cost and cost <= unit.moves then
    return true
  end
  return false
end


local plan_with_random_change = function(plan)
  
  local added_action_choices = {}
  for i,unit in ipairs(our_ai.our_units) do
    local updated = latest_info(plan, unit)
    local src = { x = updated.x, y = updated.y }
    local dsts = get_locations_xy({
      x = updated.x,
      y = updated.y,
      radius = updated.moves
    }
    for i,dst in dsts do
      if can_reach(plan, updated, dst) then
        local attack_type = "attack"
        if dst.x ~= updated.x or dst.y ~= updated.y then
          table.insert(added_action_choices, { type = "move", uid = unit.underlying_id, source = src, destination = dst })
          attack_type = "move_and_attack"
        end
        
        local maybe_attackables = wesnoth.get_units({
          { "filter_location", {
            x = dst.x,
            y = dst.y,
            radius = 1
          }}
        })
        for i,maybe_attackable in ipairs(maybe_attackables) do
          if is_enemy(unit.side, maybe_attackable.side) then
            for each weapon "weapon" the unit has do
              table.insert(added_action_choices, { type = attack_type, uid = unit.underlying_id, source = src, destination = dst, attack = { x = maybe_attackable.x, y = maybe_attackable.y, weapon = weapon }})
            end
          end
        end
      end
    end
  end
end

function our_ai:do_moves()
  self.our_units = wesnoth.get_units({ side = builtin_ai_stuff.side })
  
  local current_plan = {}
  local current_eval = evaluate_plan(current_plan)
  
  local max_countdown = 1000000
  self.countdown = max_countdown
  
  while countdown > 0 do
    self.countdown = self.countdown - 100
    local new_plan = plan_with_random_change(current_plan)
    local new_eval = evaluate_plan(new_plan)
    if (new_eval > old_eval) or math.random() < self.countdown / max_countdown then
      current_plan = new_plan
      current_eval = new_eval
    end
  end
  
  for i,action in ipairs(plan) do
    if action.type == "move" or action.type == "move_and_attack" then
      builtin_ai_stuff.move(action.src.x, action.src.y, action.dst.x, action.dst.y)
    end
    if action.type == "attack" or action.type == "move_and_attack" then
      builtin_ai_stuff.attack(action.dst.x, action.dst.y, action.attack.x, action.attack.y, action.attack.weapon)
    end
  end
end

return our_ai
--! ==============================================================
>>
  [/engine]
  [stage]
    engine="lua"
    code="(...):do_moves()"
  [/stage]
[/ai]

