[ai]
  version=1071034
  [engine]
    name="lua"
    code= <<
--! ==============================================================
helper = wesnoth.require("lua/helper.lua")

local builtin_ai_stuff = ...
local our_ai = { }
--local ai_stdlib = wesnoth.require('ai/lua/stdlib.lua')
--ai_stdlib.init(builtin_ai_funcs)

local function naive_deep_copy(table)
  local output = {}
  for k,v in pairs(table) do
    if type(v) == "table" then output[k] = naive_deep_copy(v)
    else output[k] = v end
  end
  return output
end

local get_locations = function(filter)
  local result = wesnoth.get_locations(filter)
  for i,entry in ipairs(result) do
    entry.x = entry[1]
    entry.y = entry[2]
  end
  return result
end

local latest_info = function(plan, unit, after_this_index)
  after_this_index = after_this_index or table.getn(plan)
  local result = wesnoth.copy_unit(unit)
  local i = 1
  while i <= after_this_index do
    local action = plan[after_this_index]
    if action.uid == unit.underlying_id and (action.type == "move" or action.type == "move_and_attack") then
      local path, cost = wesnoth.find_path(result, action.dst.x, action.dst.y)
      result.x = action.dst.x
      result.y = action.dst.y
      result.moves = result.moves - cost
    end
    i = i + 1
  end
  return result
end

local can_reach = function(plan, unit, dst, after_this_index)
  after_this_index = after_this_index or table.getn(plan)
  local path, cost = wesnoth.find_path(unit, dst.x, dst.y, { max_cost = unit.moves })
  -- TODO what's the actual return value if there's no path
  if path and cost and cost <= unit.moves then
    return true
  end
  return false
end


local plan_with_random_change = function(our_ai, plan)
  
  local added_action_choices = {}
  for i,unit in ipairs(our_ai.our_units) do
    local updated = latest_info(plan, unit)
    local src = { x = updated.x, y = updated.y }
    local dsts = get_locations({
      x = updated.x,
      y = updated.y,
      radius = updated.moves
    })
    for i,dst in ipairs(dsts) do
      if can_reach(plan, updated, dst) then
        local attack_type = "attack"
        if dst.x ~= updated.x or dst.y ~= updated.y then
          table.insert(added_action_choices, { type = "move", uid = unit.underlying_id, src = src, dst = dst })
          attack_type = "move_and_attack"
        end
        
        local maybe_attackables = wesnoth.get_units({
          { "filter_location", {
            x = dst.x,
            y = dst.y,
            radius = 1
          }}
        })
        for i,maybe_attackable in ipairs(maybe_attackables) do
          if wesnoth.is_enemy(unit.side, maybe_attackable.side) then
            --for each weapon "weapon" the unit has do
              table.insert(added_action_choices, { type = attack_type, uid = unit.underlying_id, src = src, dst = dst, attack = { x = maybe_attackable.x, y = maybe_attackable.y, weapon = 0 }})
            --end
          end
        end
      end
    end
  end
  
  local new_plan = naive_deep_copy(plan)
  
  local choice = math.random(table.getn(added_action_choices) + table.getn(plan))
  if added_action_choices[choice] then table.insert(new_plan, added_action_choices[choice])
  else table.remove(new_plan, table.getn(added_action_choices)) end
  return new_plan
end

function evaluate_plan(plan)
  return 0
end

function our_ai:do_moves()
  self.our_units = wesnoth.get_units({ side = builtin_ai_stuff.side })
  
  local current_plan = {}
  local current_eval = evaluate_plan(current_plan)
  
  local max_countdown = 100000
  self.countdown = max_countdown
  
  while self.countdown > 0 do
    self.countdown = self.countdown - 100
    local new_plan = plan_with_random_change(self, current_plan)
    local new_eval = evaluate_plan(new_plan)
    if (new_eval > current_eval) or math.random() < (self.countdown / max_countdown) then
      current_plan = new_plan
      current_eval = new_eval
    end
  end
  
  for i,action in ipairs(current_plan) do
    if action.type == "move" or action.type == "move_and_attack" then
      builtin_ai_stuff.move(action.src.x, action.src.y, action.dst.x, action.dst.y)
    end
    if action.type == "attack" or action.type == "move_and_attack" then
      builtin_ai_stuff.attack(action.dst.x, action.dst.y, action.attack.x, action.attack.y, action.attack.weapon)
    end
  end
  
  local units = wesnoth.get_units({ side = builtin_ai_stuff.side })
  for i,unit in ipairs(units) do
    builtin_ai_stuff.move_full(unit.x, unit.y, unit.x, unit.y)
  end
end

return our_ai
--! ==============================================================
>>
  [/engine]
  [stage]
    engine="lua"
    code="(...):do_moves()"
  [/stage]
[/ai]

