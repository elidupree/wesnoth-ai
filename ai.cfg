[ai]
  version=10710
  [engine]
    name="lua"
    code= <<
--! ==============================================================
helper = wesnoth.require("lua/helper.lua")

local builtin_ai_stuff = ...
local our_ai = { }
local ai_stdlib = wesnoth.require('ai/lua/stdlib.lua')
ai_stdlib.init(builtin_ai_funcs)

local function naive_deep_copy(table)
  local output = {}
  for k,v in pairs(table) do
    if type(v) == "table" then output[k] = naive_deep_copy(v)
    else output[k] = v end
  end
  return output
end

local get_locations_xy = function(filter)
  local result = wesnoth.get_locations(filter)
  for i,entry in ipairs(result) do
    result.x = result[1]
    result.y = result[2]
  end
end

local latest_location = function(plan, unit, after_this_index)
  after_this_index = after_this_index or table.getn(plan)
  while after_this_index > 0 do
    local action = plan[after_this_index]
    if action.uid == unit.underlying_id and (action.type == "move" or action.type == "move_and_attack") then
      return action.destination
    end
    after_this_index = after_this_index - 1
  end
  return { x = unit.x, y = unit.y }
end

local can_reach = function(plan, unit, destination, after_this_index)
  after_this_index = after_this_index or table.getn(plan)
  if wesnoth.find_path()
end


local plan_with_random_change = function(plan)
  
  local added_action_choices = {}
  for i,unit in ipairs(our_ai.our_units) do
    local src = latest_location(plan, unit)
    local dsts = get_locations_xy({
      x = src.x,
      y = src.y,
      radius = unit.max_moves
    }
    for i,dst in dsts do
      if can_reach(plan, unit, dst) then
        local attack_type = "attack"
        if dst.x ~= src.x or dst.y ~= src.y then
          table.insert(added_action_choices, { type = "move" uid = unit.underlying_id, source = src, destination = dst })
          attack_type = "move_and_attack"
        end
        
        local maybe_attackables = wesnoth.get_units({
          { "filter_location", {
            x = dst.x,
            y = dst.y,
            radius = 1
          }}
        })
        for i,maybe_attackable in ipairs(maybe_attackables) do
          if is_enemy(unit.side, maybe_attackable.side) then
            for each weapon "weapon" the unit has do
              table.insert(added_action_choices, { type = attack_type, uid = unit.underlying_id, source = src, destination = dst, attack = { x = maybe_attackable.x, y = maybe_attackable.y, weapon = weapon }})
            end
          end
        end
      end
    end
    
    --[[local maybe_attackable = wesnoth.get_units({
      { "filter_location", {
        x = unit.x,
        y = unit.y,
        radius = unit.max_moves
      }}
    })
    if is_enemy(unit.side, maybe_attackable.side) then
      local locations_for_attack = wesnoth.get_locations({
        { "not", {
          { "filter", {
          }},
        }},
        { "and", {
          x = maybe_attackable.x,
          y = maybe_attackable.y,
          radius = 1
        }}
      })
      for i,loc in ipairs(locations_for_attack) do
        local dst = { x = loc[1], y = loc[2] }
        if can_reach(plan, unit, dst) then
          for each weapon "weapon" the unit has do
            table.insert(attack_choices, { source = src, destination = dst, attack = { maybe_attackable.x, maybe_attackable.y, weapon }}
          end
        end
      end
    end]]
  end
end

function our_ai:do_moves()
  self.our_units = wesnoth.get_units({ side = builtin_ai_stuff.side })
  
  local current_plan = {}
  local current_eval = evaluate_plan(current_plan)
  
  local max_countdown = 1000000
  self.countdown = max_countdown
  
  while countdown > 0 do
    self.countdown = self.countdown - 100
    local new_plan = plan_with_random_change(current_plan)
    local new_eval = evaluate_plan(new_plan)
    if (new_eval > old_eval) or math.random() < self.countdown / max_countdown then
      current_plan = new_plan
      current_eval = new_eval
    end
  end
  
  for i,action in ipairs(plan) do
    if action.type == "move" or action.type == "move_and_attack" then
      builtin_ai_stuff.move(action.src.x, action.src.y, action.dst.x, action.dst.y)
    end
    if action.type == "attack" or action.type == "move_and_attack" then
      builtin_ai_stuff.attack(action.dst.x, action.dst.y, action.attack.x, action.attack.y, action.attack.weapon)
    end
  end
end

return our_ai
--! ==============================================================
>>
  [/engine]
  [stage]
    engine="lua"
    code="(...):do_moves()"
  [/stage]
[/ai]

