#ifdef MULTIPLAYER

[era]
    id=era_default_lua
    name= _ "Default / Lua AI"

    {ERA_DEFAULT}
    
    [event]
      name=start
      [set_menu_item]
        id="change_to_ai"
        image="items/book3.png~CROP(19,18,36,36)"
        description=_"Give this side to the Lua AI"
        [command]
          [modify_side]
            side=$side_number
            controller=ai
            {./ai.cfg}
          [/modify_side]
        [/command]
      [/set_menu_item]
    [/event]
[/era]













[multiplayer]
id=Tiny_Close_Relation_LAI
name="MC_AI+(Tiny) Close Relation (2p)"
description="The Close Relation
Part of the Tiny Maps Pack
For 2 players

Created by Belbog."

map_data="border_size=1
usage=map

Mm^Xm       , Mm^Xm       , Mm^Xm       , Ww          , Md^Xm       , Md^Xm       , Md^Xm       
Mm^Xm       , Mm^Xm       , Cud         , Ww          , Ce          , Md^Xm       , Md^Xm       
Mm^Xm       , 2 Kud       , Cud         , Wwf         , Ce          , 1 Ke        , Md^Xm       
Mm^Xm       , Mm^Vhh      , Mm^Xm       , Ww          , Md^Xm       , Mm^Vc       , Md^Xm       
Mm^Xm       , Mm^Xm       , Mm^Xm       , Ww          , Md^Xm       , Md^Xm       , Md^Xm "
{DEFAULT_SCHEDULE}
{DEFAULT_MUSIC_PLAYLIST}

turns = -1

[event]
name=preload
{./inspect.cfg}
[/event]

[side]
side=1
team_name=1
controller=human
canrecruit=yes
gold=40
income=0
fog=no
village_gold=3
team_lock=yes
[/side]

[side]
            {./ai_rnn.cfg}
side=2
team_name=2
controller=human
canrecruit=yes
gold=40
income=0
fog=no
village_gold=3
team_lock=yes
[/side]


{./ai_rnn_setup.cfg}



# Hackily include some of the code from Modular Multiplayer Campaign
# in order to repeat the same scenario multiple times within the same lua context

[event]
name=preload
[lua]
code=<<--mmcbs
helper = wesnoth.require ("lua/helper.lua")

MMC = MMC or {}
MMC.heal_unit = function (unit)
  unit.hitpoints = unit.max_hitpoints
  unit.status.poisoned = false
  unit.status.slowed = false
end
MMC.factions = {}
for faction in helper.child_range (wesnoth.game_config.era, "multiplayer_side") do
  if not faction.random_faction then table.insert (MMC.factions, faction) end
end
MMC.random_leader = function (faction)
  local leader_type =helper.rand (faction.random_leader)
  -- fall back to leader= and resist errors caused by buggy eras
  while not (leader_type and wesnoth.unit_types [leader_type]) do
    leader_type = helper.rand (faction.leader)
  end
  return leader_type
end
MMC.begin_scenario = function ()
  scenario_began_turn = wesnoth.current.turn
  local units = wesnoth.get_units ({})
  for I, unit in ipairs (units ) do
    wesnoth.extract_unit (unit)
  end

  local positions = (math.random (1, 2) ==1) and {1, 2} or {2, 1}
  for I, side in ipairs (wesnoth.sides) do
    side.gold = 40
    local faction = MMC.factions [helper.rand ("1.." ..  #MMC.factions)]
    wesnoth.put_unit ({
x = wesnoth.get_variable ("MMC_start_X" .. positions [I]),
y = wesnoth.get_variable ("MMC_start_Y" .. positions [I]),
type = MMC.random_leader (faction),
side = I,
canrecruit = true,
    })
    wesnoth.fire ("set_recruit", {side = I, recruit = faction.recruit})
  end
  scenario_began and scenario_began()
end

>>
[/lua]
[/event]

[event]
name=prestart
[lua]
code=<<--mmcps
local units = wesnoth.get_units ({canrecruit = true})
for I, unit in ipairs (units) do
  wesnoth.set_variable ("MMC_start_X" ..  unit.side,unit.x)
  wesnoth.set_variable ("MMC_start_Y" ..  unit.side, unit.y)
  wesnoth.extract_unit (unit)
end
wesnoth.set_variable ("MMC_scenario_number", 0)
MMC.begin_scenario ()

fitness = 0
>>
[/lua]
[/event]

[event]
name=die
first_time_only=no
[filter]
canrecruit=true
[/filter]
[lua]
code=<<--mmcd
scenario_ended and scenario_ended()
MMC.begin_scenario ()
>>
[/lua]
[/event]


# Restart if there's a stalemate
[event]
name=side_turn
first_time_only=no
[lua]
code=<<--mmcst
on_side_turn and on_side_turn()
if wesnoth.current.turn >scenario_began_turn + 40 then
  MMC.begin_scenario ()
end
>>
[/lua]
[/event]

[event]
name=side_turn_end
first_time_only=no
[lua]
code=<<--mmcst
on_side_turn_end and on_side_turn_end()
>>
[/lua]
[/event]

[event]
name=attack_end
first_time_only=no
[lua]
code=<<--mmcst
on_attack_end and on_attack_end()
>>
[/lua]
[/event]

[event]
name=attack
first_time_only=no
[lua]
code=<<--mmcst
on_attack and on_attack()
>>
[/lua]
[/event]


[event]
name=recruit
first_time_only=no
[lua]
code=<<--mmcst
on_recruit and on_recruit()
>>
[/lua]
[/event]


[event]
name=moveto
first_time_only=no
[lua]
code=<<--mmcst
on_moveto and on_moveto()
>>
[/lua]
[/event]



# Reward the AI a bit for dealing damage
[event]
name=attacker_hits
first_time_only=no
[lua]
code=<<--mmah
if wesnoth.current.side == 1 then fitness = fitness or 0 + wesnoth.get_variable ("damage_inflicted") or 0 end
>>
[/lua]
[/event]
[event]
name=defender_hits
first_time_only=no
[lua]
code=<<--mmdh
if wesnoth.current.side == 2 then fitness = fitness or 0 + wesnoth.get_variable ("damage_inflicted") or 0 end
>>
[/lua]
[/event]


[/multiplayer]
#endif

