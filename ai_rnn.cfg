[ai]
  version=1071034
  [engine]
    name="lua"
    code= <<--ai_rnn.cfg
--! ==============================================================
local helper = wesnoth.require("lua/helper.lua")

local builtin_ai_stuff = ...

local pack = function(...) return {...} end


local error_message = function(msg)
  wesnoth.fire("wml_message", { logger="err", message=msg })
end

local state_size = 1000
local layers = 1
local default_density = 10

local random_matrix = function (input, output)
  local result = {output_size = output}
  if input*output <30000 then
    for index = 1, input*output do
      result [index] = math.random()*2.0 - 1.0
    end
  else
    result.sparse = default_density
    for index = 1, input*result.sparse do
      result [index*2 - 1] = math.random (1, output)
      result [index*2] = math.random()*2.0 - 1.0
    end
  end
  return result
end

local move_size = 4
local attack_size = 12
local inputs
inputs = {
  sides = {
    size = 4,
    generate = function ()
      local my_side = wesnoth.sides [builtin_ai_stuff.side]
      local enemy = wesnoth.sides [1]
      return {my_side.gold, my_side.total_income, enemy.gold, enemy.total_income}
    end,
  },
  unit = {
    size = 12,
    generate = function (unit)
      return {unit.x, unit.y, unit.hitpoints, unit.moves, unit.attacks_left, (unit.max_experience - unit.experience), unit.side - 1, unit.canrecruit and 1 or 0, unit.max_hitpoints, unit.max_moves, unit.status.slowed and 1 or 0, unit.status.poisoned and 1 or 0,}
    end,
  },
  move = {
    size = move_size,
    generate = function (move)
      return {move.src_x,move.src_y,move.dst_x,move.dst_y}
    end,
  },
  attack = {
    size = attack_size,
    generate = function (attack)
      local defend_unit = wesnoth.get_unit (attack.dst_x, attack.dst_y)
      local attacker, defender = wesnoth.simulate_combat (attack.unit, attack.weapon, defend_unit)
      return {attack.src_x,attack.src_y,attack.dst_x,attack.dst_y,
        attacker.hp_chance [0], defender.hp_chance [0],
        attack.unit.hitpoints - attacker.average_hp, defend_unit.hitpoints - defender.average_hp,
        attacker.slowed, attacker.poisoned, defender.slowed, defender.poisoned
      }
    end,
  },
  move_to_attack = {
    size = move_size + attack_size,
    generate = function (move)
      local result = inputs.move.generate (move)
      for i,k in ipairs(inputs.attack.generate (move.attack)) do table.insert(result, k) end
      return result
    end
  },
  recruit = {
    size = 2,
    generate = function (recruit)
      return {recruit.x, recruit.y}
    end,
  },
}


local random_organism = function (signature)
  local result = {
    fitness = {wins = 0, games = 0, accumulated = 0, mutations = 0, signature = string.rep (signature, 10)},
    matrices = {output = random_matrix (state_size, 1),},
  }
  for key, value in pairs (inputs) do
    for layer = 1, layers do
      result.matrices [key.."input"..layer] = random_matrix (value.size, state_size)
      result.matrices [key.."hidden"..layer] = random_matrix (state_size, state_size)
      if layer >1 then result.matrices [key.."transfer"..layer] = random_matrix (state_size, state_size) end
    end
  end
  return result
end

local organisms = {}
for index=1, 9 do table.insert (organisms, random_organism(index)) end
local current_organism = organisms [1]

local mutate = function (first, rate)
  first.fitness.mutations = first.fitness.mutations + 1
  local result = {fitness = {wins = 0, games = 0, accumulated = 0, mutations = 0, signature = first.fitness.signature}, matrices = {},}
  local signature_swap =math.random (1, 10)
  result.fitness.signature = string.sub (result.fitness.signature, 1, signature_swap - 1)..math.random (0, 9).. string.sub (result.fitness.signature, signature_swap + 1, -1)
  for key, value in pairs (first.matrices) do
    local new_matrix = {output_size = value.output_size, sparse = value.sparse}
    if value.sparse then
      for index, entry in ipairs (value) do
        new_matrix [index] = value [index]
        if index % 2 == 0 then
          if math.random (1,1000) <= rate then
            new_matrix [index] = math.random()*2.0 - 1.0
          end
          if math.random (1,200) <= rate then
            new_matrix [index] = new_matrix [index] + (math.random()*2.0 - 1.0)*math.min(math.random (1,100),math.random (1,100))/200
          end
        else
          if math.random (1, 1000) <= rate then
            new_matrix [index] = math.random(1, value.output_size)
          end
        end
      end
    else
      for index, entry in ipairs (value) do
        new_matrix [index] = value [index]
        if math.random (1,100) <= rate then
          new_matrix [index] = math.random()*2.0 - 1.0
        end
        if math.random (1,20) <= rate then
          new_matrix [index] = new_matrix [index] + (math.random()*2.0 - 1.0)*math.min(math.random (1,100),math.random (1,100))/200
        end
      end
    end
    result.matrices [key] = new_matrix
  end
  return result
end

local wins = 0
local total_fitness = 0
local games = 0
local survivor_games = 0

local priority = function(organism)
  if organism.fitness.games == 0 then return 1000000 end
  return (organism.fitness.wins/organism.fitness.games) + (organism.fitness.accumulated/organism.fitness.games/10000) + (organism.fitness.wins == 0 and 0.01 or 1) * math.sqrt (0.5*math.log (survivor_games)/organism.fitness.games)
end
local promise = function(organism)
  if organism.fitness.games == 0 then return 1000000 end
  if organism.fitness.wins == 0 then return -organism.fitness.games end
  return (organism.fitness.wins/organism.fitness.games) + (organism.fitness.accumulated/organism.fitness.games/10000) + math.sqrt (1/organism.fitness.games)
end
local proof = function(organism)
  if organism.fitness.games == 0 then return -1000000 end
  return (organism.fitness.wins/organism.fitness.games) + (organism.fitness.accumulated/organism.fitness.games/10000) - math.sqrt ((2 + organism.fitness.mutations)/organism.fitness.games)
end
local raw_fitness = function(organism)
  if organism.fitness.games == 0 then return .404 end
  return (organism.fitness.wins/organism.fitness.games) + (organism.fitness.accumulated/organism.fitness.games/10000)
end

local format_organism = function (organism)
  return string.format (organism.fitness.signature.." ("..organism.fitness.wins.. "/"..organism.fitness.games.. ", %.3f)", raw_fitness (organism))
end

scenario_ended = function()
  games = games + 1
  survivor_games = survivor_games + 1
  current_organism.fitness.games = current_organism.fitness.games + 1
  current_organism.fitness.accumulated = current_organism.fitness.accumulated + fitness
  total_fitness = total_fitness + fitness
  fitness = 0

  local units = wesnoth.get_units ({})
  for I, unit in ipairs (units) do
    if unit.side ~= builtin_ai_stuff.side and unit.canrecruit and unit.hitpoints <= 0 then
      -- we won the game! Amazing!
      wins = wins + 1
      current_organism.fitness.wins = current_organism.fitness.wins + 1
    end
  end  
  --error_message(inspect(organisms,{depth=2}))
  
  local worst_index = 1
  local best = organisms[1]
  for index, organism in ipairs (organisms) do
    if priority (organism) > priority (current_organism) then
      current_organism = organism
    end
    if proof (organism) > proof (best) then
      best = organism
    end
    if promise (organism) <promise (organisms [worst_index]) then
      worst_index = index
    end
  end
  local worst = organisms [worst_index]
  
  error_message ("Game over. Wins: ".. wins.."/"..games..". Average non-win fitness so far: ".. string.format ("%.3f", total_fitness/games)..". Next up: ".. format_organism (current_organism))

  
  if games % 10 == 0 or (games % 2 == 0 and worst.fitness.wins == 0) then
    error_message ("Mutating ".. format_organism (best)..", dropping: ".. format_organism (worst)..".")
    survivor_games = survivor_games - worst.fitness.games
    table.remove (organisms, worst_index)
    if math.random (1, 20) == 1 or raw_fitness(best) < math.random()/3 then
      table.insert (organisms, random_organism(math.floor(games/10) % 10))
    else
      table.insert (organisms, mutate (best, math.random (1,3)*math.random (1,4)))
    end
  end
  
  if games % 50 == 0 then
    local display = {}
    for index, organism in ipairs (organisms) do
      table.insert (display, format_organism (organism))
    end
    error_message ("All organisms:\n" .. table.concat (display, "\n"))
  end
end

local multiply_into = function (vector, output, matrix)
  for index = 1, matrix.output_size do output [index] = output [index] or 0 end
  for index, input in ipairs (vector) do
    if matrix.sparse then
      for entry_index = (index-1)*matrix.sparse + 1, index*matrix.sparse do
        output [matrix [entry_index*2 - 1]] = output [matrix [entry_index*2 - 1]] + input*matrix [entry_index*2]
      end
    else
      for output_index = 1, matrix.output_size do
        output [output_index] = output [output_index] + input*matrix [output_index + (index-1)*matrix.output_size]
      end
    end
  end
end

local next_hidden = function (state, input_type, input)
  local result = {}
  for layer = 1, layers do
    local next_hidden = {}
    multiply_into (state.hidden[layer], next_hidden, current_organism.matrices [input_type.."hidden"..layer])
    if layer >1 then multiply_into (result [layer - 1], next_hidden, current_organism.matrices [input_type.."transfer"..layer]) end
    multiply_into (input, next_hidden, current_organism.matrices [input_type.."input"..layer])
    for index, value in ipairs (next_hidden) do
      next_hidden [index] = (math.exp (2*value) - 1)/(math.exp (2*value) + 1)
    end
    result [layer] = next_hidden
  end
  return result
end

local process_input = function (state, input_type, input)
  state.hidden = next_hidden (state, input_type, inputs [input_type].generate (input))
end
local evaluate = function (state, input_type, input)
  local output = {}
  multiply_into (next_hidden (state, input_type, inputs [input_type].generate (input))[layers], output, current_organism.matrices.output)
  return output[1]
end


local do_move_by_type = {
  move = function(move) builtin_ai_stuff.move(move.unit, move.dst_x, move.dst_y) end,
  move_to_attack = function(move) builtin_ai_stuff.move(move.unit, move.dst_x, move.dst_y) end,
  attack = function(move) builtin_ai_stuff.attack(move.unit, move.dst_x, move.dst_y, move.weapon and move.weapon-1) end,
  recruit = function(move) builtin_ai_stuff.recruit(move.unit_type, move.dst_x, move.dst_y) end,
  end_turn = function() return true end,
}

local calculate_and_do_one_move = function()
  local state = {hidden={}}
  for index = 1, layers do state.hidden [index] = {} end
  process_input (state, "sides")
  local units = wesnoth.get_units ({})
  local moves = {}
  for I, unit in ipairs (units) do
    process_input (state, "unit", unit)
    if unit.side == wesnoth.current.side then
      --error_message(inspect({"unit",unit.moves, #wesnoth.find_reach (unit)}))
      for whatever, reach_info in ipairs (wesnoth.find_reach (unit)) do
        local unit_there = wesnoth.get_unit(reach_info [1], reach_info [2])
        if not unit_there then
          table.insert (moves, {type = "move", unit=unit, src_x = unit.x,src_y = unit.y,dst_x = reach_info [1],dst_y = reach_info [2]})
        end
        if not (unit_there and unit_there ~= unit) then
        
      if unit.attacks_left > 0 then
        for X, Y in helper.adjacent_tiles (reach_info [1], reach_info [2]) do
          local neighbor = wesnoth.get_unit (X, Y)
          if neighbor and wesnoth.is_enemy(unit.side, neighbor.side) then
            local index = 0
            for attack in helper.child_range (unit.__cfg, "attack") do
              index = index + 1
              local attack_move = {type = "attack", unit=unit, src_x = reach_info [1],src_y = reach_info [2],dst_x = X,dst_y = Y, weapon = index}
              if unit_there == unit then 
                table.insert (moves, attack_move)
              else
                table.insert (moves, {type = "move_to_attack", unit=unit, src_x = unit.x,src_y = unit.y,dst_x = reach_info [1],dst_y = reach_info [2], attack = attack_move}) 
              end
            end
          end
        end
      end

        end
      end
    end
  end
  --error_message(inspect(state))
  local best_value = 0
  local best_move = {type = "end_turn"}
  for I, move in ipairs (moves) do
    local evaluation = evaluate (state, move.type, move)
    --error_message(inspect({move,evaluation}))
    if evaluation >best_value then
      best_value = evaluation
      best_move = move
    end
  end
  --error_message(inspect({"doing",best_move}))
  return do_move_by_type [best_move.type] (best_move)
end

local our_ai = { }
function our_ai:do_moves()
  for hack=1,100 do
    if calculate_and_do_one_move() then break end
  end
  
  local units = wesnoth.get_units ({})
  for I, unit in ipairs (units) do
    if unit.side == wesnoth.current.side then
      builtin_ai_stuff.stopunit_all(unit)
    end
  end
end

return our_ai
--! ==============================================================
>>
  [/engine]
  [stage]
    engine="lua"
    code="(...):do_moves()"
  [/stage]
[/ai]

