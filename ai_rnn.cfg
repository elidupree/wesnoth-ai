[ai]
  version=1071034
  [engine]
    name="lua"
    code= <<--ai_rnn.cfg
--! ==============================================================
local helper = wesnoth.require("lua/helper.lua")

local builtin_ai_stuff = ...

local pack = function(...) return {...} end


local error_message = function(msg)
  wesnoth.fire("wml_message", { logger="err", message=msg })
end

local unit_size = 3
local move_size = 4
local attack_size = 4
local recruit_size = 2
local state_size = 100

local random_matrix = function (input, output)
  local result = {output_size = output}
  for index = 1, input*output do
    result [index] = math.random()*2.0 - 1.0
  end
  return result
end
  

local random_organism = function ()
  local result = {
    unit_matrix = random_matrix (unit_size, state_size),
    unit_hidden_matrix = random_matrix (state_size, state_size),
    move_matrix = random_matrix (move_size, state_size),
    move_hidden_matrix = random_matrix (state_size, state_size),
    recruit_matrix = random_matrix (recruit_size, state_size),
    recruit_hidden_matrix = random_matrix (state_size, state_size),
    attack_matrix = random_matrix (attack_size, state_size),
    attack_hidden_matrix = random_matrix (state_size, state_size),
    output_matrix = random_matrix (state_size, 1),
  }
  return result
end

local organisms = {random_organism(), random_organism()}
local current_organism = organisms [1]

local multiply_into = function (vector, output, matrix)
  for index = 1, matrix.output_size do output [index] = output [index] or 0 end
  for index, input in ipairs (vector) do
    for output_index = 1, matrix.output_size do
      output [output_index] = output [output_index] + input*matrix [output_index + (index-1)*matrix.output_size]
    end
  end
end

local next_hidden = function (state, input, input_matrix, hidden_matrix)
  local next_hidden = {}
  multiply_into (state.hidden, next_hidden, hidden_matrix)
  multiply_into (input, next_hidden, input_matrix)
  for index, value in ipairs (next_hidden) do
    next_hidden [index] = (math.exp (2*value) - 1)/(math.exp (2*value) + 1)
  end
  return next_hidden
end

local process_input = function (state, input, input_matrix, hidden_matrix)
  state.hidden = next_hidden (state, input, input_matrix, hidden_matrix)
end

local process_unit = function (state, unit)
  process_input (state, {unit.x, unit.y, unit.side - 1}, current_organism.unit_matrix, current_organism.unit_hidden_matrix)
end

local evaluate_move = function (state, move)
  local result = {} 
  multiply_into (next_hidden (state, {move.src_x,move.src_y,move.dst_x,move.dst_y}, current_organism.move_matrix, current_organism.move_hidden_matrix), result, current_organism.output_matrix)
  return result [1]
end

local evaluate_attack = function (state, attack)
  local result = {} 
  multiply_into (next_hidden (state, {attack.src_x,attack.src_y,attack.dst_x,attack.dst_y}, current_organism.attack_matrix, current_organism.attack_hidden_matrix), result, current_organism.output_matrix)
  return result [1]
end

local evaluate_recruit = function (state, recruit)
  local result = {} 
  multiply_into (next_hidden (state, {recruit.x, recruit.y}, current_organism.recruit_matrix, current_organism.recruit_hidden_matrix), result, current_organism.output_matrix)
  return result [1]
end



local do_move_by_type = {
  move = function(move) builtin_ai_stuff.move(move.unit, move.dst_x, move.dst_y) end,
  attack = function(move) builtin_ai_stuff.attack(move.unit, move.dst_x, move.dst_y, move.weapon-1) end,
  recruit = function(move) builtin_ai_stuff.recruit(move.unit_type, move.dst_x, move.dst_y) end,
  end_turn = function() return true end,
}

local calculate_and_do_one_move = function()
  local state = {hidden={}}
  for index = 1, state_size do state [index] = 0 end
  local units = wesnoth.get_units ({})
  local moves = {}
  for I, unit in ipairs (units) do
    process_unit (state, unit)
    if unit.side == wesnoth.current.side then
    error_message(inspect({"unit",unit.moves, #wesnoth.find_reach (unit)}))
      for whatever, reach_info in ipairs (wesnoth.find_reach (unit)) do
        if not wesnoth.get_unit(reach_info [1], reach_info [2]) then
          table.insert (moves, {type = "move", unit=unit, src_x = unit.x,src_y = unit.y,dst_x = reach_info [1],dst_y = reach_info [2]})
        end
      end
      if unit.attacks_left > 0 then
        for X, Y in helper.adjacent_tiles (unit.x, unit.y) do
          local neighbor = wesnoth.get_unit (X, Y)
          if neighbor and wesnoth.is_enemy(unit.side, neighbor.side) then
            table.insert (moves, {type = "attack", unit=unit, src_x = unit.x,src_y = unit.y,dst_x = X,dst_y = Y, weapon = 1})
          end
        end
      end
    end
  end
  
  local best_value = 0
  local best_move = {type = "end_turn"}
  for I, move in ipairs (moves) do
    local evaluation
    if move.type == "move" then evaluation = evaluate_move (state, move) end
    if move.type == "attack" then evaluation = evaluate_attack (state, move) end
    if move.type == "recruit" then evaluation = evaluate_recruit (state, move) end
    
    error_message(inspect({move,evaluation}))
    if evaluation >best_value then
      best_value = evaluation
      best_move = move
    end
  end
    error_message(inspect({"doing",best_move}))
  return do_move_by_type [best_move.type] (best_move)
end

local our_ai = { }
function our_ai:do_moves()
  for hack=1,100 do
    if calculate_and_do_one_move() then break end
  end
  
  local units = wesnoth.get_units ({})
  for I, unit in ipairs (units) do
    if unit.side == wesnoth.current.side then
      builtin_ai_stuff.stopunit_all(unit)
    end
  end
end

return our_ai
--! ==============================================================
>>
  [/engine]
  [stage]
    engine="lua"
    code="(...):do_moves()"
  [/stage]
[/ai]

