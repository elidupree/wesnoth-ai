[ai]
  version=1071034
  [engine]
    name="lua"
    code= <<--ai_rnn.cfg
--! ==============================================================
local helper = wesnoth.require("lua/helper.lua")

local builtin_ai_stuff = ...

local pack = function(...) return {...} end


local error_message = function(msg)
  wesnoth.fire("wml_message", { logger="err", message=msg })
end

local state_size = 150
local layers = 3

local random_matrix = function (input, output)
  local result = {output_size = output}
  for index = 1, input*output do
    result [index] = math.random()*2.0 - 1.0
  end
  return result
end

local inputs = {
  unit = {
    size = 10,
    generate = function (unit)
      return {unit.x, unit.y, unit.hitpoints, unit.moves, unit.attacks_left, (unit.max_experience - unit.experience), unit.side - 1, unit.canrecruit and 1 or 0, unit.max_hitpoints, unit.max_moves,}
    end,
  },
  move = {
    size = 4,
    generate = function (move)
      return {move.src_x,move.src_y,move.dst_x,move.dst_y}
    end,
  },
  attack = {
    size = 4,
    generate = function (attack)
      return {attack.src_x,attack.src_y,attack.dst_x,attack.dst_y}
    end,
  },
  recruit = {
    size = 2,
    generate = function (recruit)
      return {recruit.x, recruit.y}
    end,
  },
}


local random_organism = function (signature)
  local result = {
    fitness = {wins = 0, games = 0, accumulated = 0, mutations = 0, signature = string.rep (signature, 10)},
    matrices = {output = random_matrix (state_size, 1),},
  }
  for key, value in pairs (inputs) do
    for layer = 1, layers do
      result.matrices [key.."input"..layer] = random_matrix (value.size, state_size)
      result.matrices [key.."hidden"..layer] = random_matrix (state_size, state_size)
      if layer >1 then result.matrices [key.."transfer"..layer] = random_matrix (state_size, state_size) end
    end
  end
  return result
end

local organisms = {}
for index=1, 9 do table.insert (organisms, random_organism(index)) end
local current_organism = organisms [1]

local mutate = function (first, rate)
  first.fitness.mutations = first.fitness.mutations + 1
  local result = {fitness = {wins = 0, games = 0, accumulated = 0, mutations = 0, signature = first.fitness.signature}, matrices = {},}
  local signature_swap =math.random (1, 10)
  result.fitness.signature = string.sub (result.fitness.signature, 1, signature_swap - 1)..math.random (0, 9).. string.sub (result.fitness.signature, signature_swap + 1, -1)
  for key, value in pairs (first.matrices) do
      local new_matrix = {output_size = value.output_size}
      for index, entry in ipairs (value) do
        new_matrix [index] = value [index]
        if math.random (1,100) <= rate then
          new_matrix [index] = math.random()*2.0 - 1.0
        end
        if math.random (1,20) <= rate then
          new_matrix [index] = new_matrix [index] + (math.random()*2.0 - 1.0)*math.min(math.random (1,100),math.random (1,100))/200
        end
      end
      result.matrices [key] = new_matrix
  end
  return result
end

local wins = 0
local total_fitness = 0
local games = 0
local survivor_games = 0

local priority = function(organism)
  if organism.fitness.games == 0 then return 1000000 end
  return (organism.fitness.wins/organism.fitness.games) + (organism.fitness.accumulated/organism.fitness.games/10000) + math.sqrt (0.5*survivor_games/organism.fitness.games)
end
local promise = function(organism)
  if organism.fitness.games == 0 then return 1000000 end
  if organism.fitness.wins == 0 then return -organism.fitness.games end
  return (organism.fitness.wins/organism.fitness.games) + (organism.fitness.accumulated/organism.fitness.games/10000) + math.sqrt (2/organism.fitness.games)
end
local proof = function(organism)
  if organism.fitness.games == 0 then return -1000000 end
  return (organism.fitness.wins/organism.fitness.games) + (organism.fitness.accumulated/organism.fitness.games/10000) - math.sqrt ((2 + organism.fitness.mutations)/organism.fitness.games)
end
local raw_fitness = function(organism)
  if organism.fitness.games == 0 then return "undefined" end
  return (organism.fitness.wins/organism.fitness.games) + (organism.fitness.accumulated/organism.fitness.games/10000)
end

local format_organism = function (organism)
  return string.format (organism.fitness.signature.." ("..organism.fitness.wins.. "/"..organism.fitness.games.. ", %.3f)", raw_fitness (organism))
end

scenario_ended = function()
  games = games + 1
  survivor_games = survivor_games + 1
  current_organism.fitness.games = current_organism.fitness.games + 1
  current_organism.fitness.accumulated = current_organism.fitness.accumulated + fitness
  total_fitness = total_fitness + fitness
  fitness = 0

  local units = wesnoth.get_units ({})
  for I, unit in ipairs (units) do
    if unit.side ~= builtin_ai_stuff.side and unit.canrecruit and unit.hitpoints <= 0 then
      -- we won the game! Amazing!
      wins = wins + 1
      current_organism.fitness.wins = current_organism.fitness.wins + 1
    end
  end  
  --error_message(inspect(organisms,{depth=2}))
  
  local worst_index = 1
  local best = organisms[1]
  for index, organism in ipairs (organisms) do
    if priority (organism) > priority (current_organism) then
      current_organism = organism
    end
    if proof (organism) > proof (best) then
      best = organism
    end
    if promise (organism) <promise (organisms [worst_index]) then
      worst_index = index
    end
  end
  local worst = organisms [worst_index]
  
  error_message ("Game over. Wins: ".. wins.."/"..games..". Average non-win fitness so far: ".. (total_fitness/games)..". Next up: ".. format_organism (current_organism))

  
  if games % 10 == 0 or (games >= 5 and worst.fitness.wins == 0) then
    error_message ("Mutating ".. format_organism (best)..", dropping: ".. format_organism (worst)..".")
    survivor_games = survivor_games - worst.fitness.games
    table.remove (organisms, worst_index)
    table.insert (organisms, mutate (best, math.random (1,4)))
  end
end

local multiply_into = function (vector, output, matrix)
  for index = 1, matrix.output_size do output [index] = output [index] or 0 end
  for index, input in ipairs (vector) do
    for output_index = 1, matrix.output_size do
      output [output_index] = output [output_index] + input*matrix [output_index + (index-1)*matrix.output_size]
    end
  end
end

local next_hidden = function (state, input_type, input)
  local result = {}
  for layer = 1, layers do
    local next_hidden = {}
    multiply_into (state.hidden[layer], next_hidden, current_organism.matrices [input_type.."hidden"..layer])
    if layer >1 then multiply_into (result [layer - 1], next_hidden, current_organism.matrices [input_type.."transfer"..layer]) end
    multiply_into (input, next_hidden, current_organism.matrices [input_type.."input"..layer])
    for index, value in ipairs (next_hidden) do
      next_hidden [index] = (math.exp (2*value) - 1)/(math.exp (2*value) + 1)
    end
    result [layer] = next_hidden
  end
  return result
end

local process_input = function (state, input_type, input)
  state.hidden = next_hidden (state, input_type, inputs [input_type].generate (input))
end
local evaluate = function (state, input_type, input)
  local output = {}
  multiply_into (next_hidden (state, input_type, inputs [input_type].generate (input))[layers], output, current_organism.matrices.output)
  return output[1]
end


local do_move_by_type = {
  move = function(move) builtin_ai_stuff.move(move.unit, move.dst_x, move.dst_y) end,
  attack = function(move) builtin_ai_stuff.attack(move.unit, move.dst_x, move.dst_y, move.weapon and move.weapon-1) end,
  recruit = function(move) builtin_ai_stuff.recruit(move.unit_type, move.dst_x, move.dst_y) end,
  end_turn = function() return true end,
}

local calculate_and_do_one_move = function()
  local state = {hidden={}}
  for index = 1, layers do state.hidden [index] = {} end
  local units = wesnoth.get_units ({})
  local moves = {}
  for I, unit in ipairs (units) do
    process_input (state, "unit", unit)
    if unit.side == wesnoth.current.side then
      --error_message(inspect({"unit",unit.moves, #wesnoth.find_reach (unit)}))
      for whatever, reach_info in ipairs (wesnoth.find_reach (unit)) do
        if not wesnoth.get_unit(reach_info [1], reach_info [2]) then
          table.insert (moves, {type = "move", unit=unit, src_x = unit.x,src_y = unit.y,dst_x = reach_info [1],dst_y = reach_info [2]})
        end
      end
      if unit.attacks_left > 0 then
        local best_attack
        local best_attack_strength = 0
        local index = 0
        for attack in helper.child_range (unit.__cfg, "attack") do
          index = index + 1
          local strength = attack.damage*attack.number
          if not (best_attack and best_attack_strength > strength) then
            best_attack = index
            best_attack_strength = strength
          end
        end
        for X, Y in helper.adjacent_tiles (unit.x, unit.y) do
          local neighbor = wesnoth.get_unit (X, Y)
          if best_attack and neighbor and wesnoth.is_enemy(unit.side, neighbor.side) then
            table.insert (moves, {type = "attack", unit=unit, src_x = unit.x,src_y = unit.y,dst_x = X,dst_y = Y, weapon = nil --[[best_attack]]})
          end
        end
      end
    end
  end
  --error_message(inspect(state))
  local best_value = 0
  local best_move = {type = "end_turn"}
  for I, move in ipairs (moves) do
    local evaluation = evaluate (state, move.type, move)
    --error_message(inspect({move,evaluation}))
    if evaluation >best_value then
      best_value = evaluation
      best_move = move
    end
  end
  --error_message(inspect({"doing",best_move}))
  return do_move_by_type [best_move.type] (best_move)
end

local our_ai = { }
function our_ai:do_moves()
  for hack=1,100 do
    if calculate_and_do_one_move() then break end
  end
  
  local units = wesnoth.get_units ({})
  for I, unit in ipairs (units) do
    if unit.side == wesnoth.current.side then
      builtin_ai_stuff.stopunit_all(unit)
    end
  end
end

return our_ai
--! ==============================================================
>>
  [/engine]
  [stage]
    engine="lua"
    code="(...):do_moves()"
  [/stage]
[/ai]

