[event]
name=preload
[lua]
code=<<--rnnpl
helper = wesnoth.require ("lua/helper.lua")
JSON = wesnoth.require ("~add-ons/wesnoth-ai/dkjson.lua")

local alignments = {lawful = 1, chaotic = -1, neutral = 0}
local convert_unit = function (unit, terrains)
  local config = unit.__cfg
  local result = {
    x = unit.x, y = unit.y,
    side = unit.side,
    alignment = alignments [config.alignment] or 0,
    attacks_left = unit.attacks_left,
    canrecruit = unit.canrecruit,
    cost = config.cost,
    experience = unit.experience, hitpoints = unit.hitpoints,
    level = unit.level, max_experience = unit.max_experience,
    max_hitpoints = unit.max_hitpoints, max_moves = unit.max_moves,
    moves = unit.moves,
    resting = unit.resting,
    slowed = unit.status.slowed or false,
    poisoned = unit.status.poisoned or false,
    not_living = unit.status.not_living or false,
    zone_of_control = config.zoc,
    defense = {},
    movement_costs = {},
    resistance = {},
    attacks = {},
  }
  for key, value in pairs (terrains) do
    result.defense [key] = wesnoth.unit_defense (unit, key)
    result.movement_costs [key] = wesnoth.unit_movement_cost (unit, key)
  end
  for key, value in pairs ({fire = true, cold = true, arcane = true, blade = true, pierce = true, impact = true})
    result.resistance [key] = wesnoth.unit_resistance (unit, key)
  end
  for index, attack in ipairs (helper.child_range (config, "attack")) do
    table.insert (result.attacks, {
      damage = attack.damage,
      number = attack.number,
      damage_type = attack.type,
      range = attack.range,
    })
  end
  return result
end

dump_map = function ()
  local width, height = wesnoth.get_map_size()
  local map = {
    config = {
      unit_type_examples = {},
      terrain_info = {},
      factions = {},
    },
    width = width,
    height = height,
    locations = {},
    starting_locations = {},
  }
  for Y = 1, height do for X = 1, width do
    local terrain =wesnoth.get_terrain (X, Y)
    local info = wesnoth.get_terrain_info (terrain)
    map.context.terrain_info [terrain] = {
      castle = info.castle,
      keep = info.keep,
      village = info.village,
      healing = info.healing,
    }
    locations [X + (Y-1)*width] = {
      terrain = terrain,
      village_owner = wesnoth.get_village_owner (X, Y),
      unit = nil,
    }
  end end
  local do_unit_type = function (unit_type)
    state.config.unit_type_examples [unit_type] = convert_unit (wesnoth.create_unit ({type = unit_type, side = 1, random_traits = false, random_gender = false, generate_name = false}), map.terrain_info)
  end
  for faction in helper.child_range (wesnoth.game_config.era, "multiplayer_side") do
    local converted = {recruits = {}, leaders = {}}
    for recruit in string.gmatch (faction.recruit, "[^,]+") do
      do_unit_type (recruit)
      table.insert (converted.recruits, recruit)
    end
    for leader in string.gmatch (faction.leader, "[^,]+") do
      do_unit_type (leader)
      table.insert (converted.leaders, leader)
    end
    table.insert (map.config.factions, converted)
  end
  for side in pairs (wesnoth.sides) do
    local location = wesnoth.get_starting_location (side)
    table.insert (starting_locations, location)
  end
  
  return map
end

local unit_size = 20
local move_size = 2 + unit_size
local attack_size = 12 + unit_size + unit_size

local neural_unit = function (unit)
  local result = {
    unit.x, unit.y,
    unit.moves, unit.attacks_left,
    unit.hitpoints, (unit.max_experience - unit.experience),
    wesnoth.is_enemy (wesnoth.current.side, unit.side) and 0 or 1, unit.canrecruit and 1 or 0,
    unit.max_hitpoints, unit.max_moves,
    unit.slowed and 1 or 0, unit.poisoned and 1 or 0, unit.not_living and 1 or 0,
    unit.alignment,
    unit.zone_of_control and 1 or 0,
    unit.resistance.blade,
    unit.resistance.pierce,
    unit.resistance.impact,
    unit.resistance.fire,
    unit.resistance.cold,
    unit.resistance.arcane,
  }
  return result
end

local unit_examples = {}
local neural_unit_type = function (type_name, X, Y)
  if not unit_examples [type_name] then
    unit_examples [type_name] = convert_unit (wesnoth.create_unit ({type = type_name, side = 1, random_traits = false, random_gender = false, generate_name = false}), {})
  end
  unit_examples [type_name].side = wesnoth.current.side
  unit_examples [type_name].x = X
  unit_examples [type_name].y = Y
  return neural_unit (unit_examples [type_name])
end

local inputs
inputs = {
  sides = {
    size = 4,
    generate = function ()
      local my_side = wesnoth.sides [wesnoth.current.side]
      local enemy = wesnoth.sides [(wesnoth.current.side % 2) + 1]
      return {my_side.gold, my_side.total_income, enemy.gold, enemy.total_income}
    end,
  },
  unit = {
    size = unit_size,
    generate = function (unit)
      return neural_unit (unit)
    end,
  },
  move = {
    size = move_size,
    generate = function (move)
      local result = {move.dst_x,move.dst_y}
      for index, value in ipairs (neural_unit (move.unit)) do table.insert (result, value) end
      return result
    end,
  },
  attack = {
    size = attack_size,
    generate = function (attack)
      local defend_unit = wesnoth.get_unit (attack.dst_x, attack.dst_y)
      local attacker, defender = wesnoth.simulate_combat (attack.unit, attack.weapon or defend_unit, attack.weapon and defend_unit)
      local result = {
        attack.src_x,attack.src_y,attack.dst_x,attack.dst_y,
        attacker.hp_chance [0], defender.hp_chance [0],
        attack.unit.hitpoints - attacker.average_hp, defend_unit.hitpoints - defender.average_hp,
        attacker.slowed, attacker.poisoned, defender.slowed, defender.poisoned
      }
      for index, value in ipairs (unit_info (attack.unit)) do table.insert (result, value) end
      for index, value in ipairs (unit_info (defend_unit)) do table.insert (result, value) end
      return result
    end,
  },
  recruit = {
    size = unit_size,
    generate = function (recruit)
      return neural_unit_type (recruit.unit_type, recruit.dst_x, recruit.dst_y)) do table.insert (result, value)
    end,
  },
}


scenario_began = function()
  this_scenario_moves = 1 -- hack, avoid possible NaN
  fitness = 0
  for index, organism in ipairs (organisms) do
    organism.fitness.current_approval = {}
    for side in ipairs (wesnoth.sides) do
      organism.fitness.current_approval [side] = 0
    end
  end
  imagine_moves()
end


local hyperbolic_tangent = function (value)
  return (math.exp (2*value) - 1)/(math.exp (2*value) + 1)
end

local multiply_into = function (input, output, matrix)
  assert (#input == matrix.input_size)
  local output_size = matrix.output_size
  for index = 1, output_size do output [index] = output [index] or 0 end
  for input_index, input_value in ipairs (vector) do
    for output_index, output_value in ipairs (output) do
      output [output_index] = output_value + input_value*matrix [output_index + (input_index-1)*output_size]
    end
  end
end

local next_memory = function (organism, memory, input)
  local result = {layers = {}}
  for layer = 1, #organism.layer_sizes do
    local next_layer = {}
    local layer_weights = organism.weights_by_input [input.input_type] [layer]
    multiply_into (memory.layers [layer], next_layer, layer_weights.hidden_matrix)
    multiply_into ((layer == 0) and input.vector or result.layers [layer - 1], next_layer, layer_weights.input_matrix) end
    for index, value in ipairs (next_layer) do
      next_layer [index] = hyperbolic_tangent (value)
    end
    result.layers [layer] = next_layer
  end
  return result
end

local initial_memory = function (organism)
  local result = {}
  for layer = 1, #organism.layer_sizes do
    local next_layer = {}
    result [layer] = next_layer
  end
  return result
end


evaluate = function (organism, memory, input)
  if input_type == "end_turn" then return 0 end
  local output = {}
  multiply_into (next_memory (organism, memory, input).layers [#organism.layer_sizes], output, organism.output_weights)
  return output[1]
end

 inputs [input_type].generate (input))
inputs [input_type].generate (input))[layers]

imagine_moves = function()
  for index, organism in ipairs (organisms) do
    organism.current_state = {hidden={}}
    for index = 1, layers do organism.current_state.hidden [index] = {} end
    process_input (organism, "sides")
  end
  local units = wesnoth.get_units ({})
  imagined_moves = {{type = "end_turn"}}
  remembered_units = {}
  for I, unit in ipairs (units) do
    remembered_units [unit.id] = wesnoth.copy_unit (unit)
  end
  for I, unit in ipairs (units) do
    -- deal with the awkward case of imagining during an attack_end event
    if unit.hitpoints >0 then
    
    local unit = remembered_units[unit.id]
    for index, organism in ipairs (organisms) do
      process_input (organism, "unit", unit)
    end
    if unit.side == wesnoth.current.side then
      --error_message(inspect({"unit",unit.moves, #wesnoth.find_reach (unit)}))
      for whatever, reach_info in ipairs (wesnoth.find_reach (unit)) do
        local unit_there = wesnoth.get_unit(reach_info [1], reach_info [2])
        if not unit_there then
          table.insert (imagined_moves, {type = "move", unit=unit, src_x = unit.x,src_y = unit.y,dst_x = reach_info [1],dst_y = reach_info [2]})
        end
        if not (unit_there and unit_there ~= unit) then
        
      if unit.attacks_left > 0 then
        for X, Y in helper.adjacent_tiles (reach_info [1], reach_info [2]) do
          local neighbor = wesnoth.get_unit (X, Y)
          if neighbor and neighbor.hitpoints > 0 and wesnoth.is_enemy(unit.side, neighbor.side) then
            local index = 0
            for attack in helper.child_range (unit.__cfg, "attack") do
              index = index + 1
              local attack_move = {type = "attack", unit=unit, src_x = reach_info [1],src_y = reach_info [2],dst_x = X,dst_y = Y, weapon = nil --[[index]]}
              table.insert (imagined_moves, attack_move)
              break
            end
          end
        end
      end

        end
      end
      
      if unit.canrecruit and wesnoth.get_terrain_info (wesnoth.get_terrain (unit.x, unit.y)).keep then
        local castles = {}
        local frontier = {{unit.x, unit.y}}
        while frontier [1] do
          local current = frontier [#frontier]
          table.remove (frontier)
          for X, Y in helper.adjacent_tiles (current [1], current [2]) do
            if wesnoth.get_terrain_info (wesnoth.get_terrain (X, Y)).castle and not castles [X..","..Y] then
              castles [X..","..Y] = {X, Y}
              table.insert (frontier, {X, Y})
            end
          end
        end
        for key, value in pairs (castles) do
            if not wesnoth.get_unit (value [1], value [2]) then
              for i,recruit_type in ipairs(wesnoth.sides[wesnoth.current.side].recruit) do
                if wesnoth.unit_types[recruit_type].cost <= wesnoth.sides[wesnoth.current.side].gold then
                  table.insert (imagined_moves, {type = "recruit", dst_x = value [1], dst_y = value [2], unit_type = recruit_type})
                end
              end
              for i,recruit_type in ipairs(unit.extra_recruit) do
                if wesnoth.unit_types[recruit_type].cost <= wesnoth.sides[wesnoth.current.side].gold then
                  table.insert (imagined_moves, {type = "recruit", dst_x = value [1], dst_y = value [2], unit_type = recruit_type})
                end
              end
            end
        end
      end
    end
    
    end
  end

end





move_completed = function(completed_move)  
  for index, organism in ipairs (organisms) do
    local higher_ranked = 0
    local best_evaluation = evaluate (organism, completed_move.type, completed_move)
    for I, move in ipairs (imagined_moves) do
      local evaluation = evaluate (organism, move.type, move)
      if evaluation > best_evaluation then
        higher_ranked = higher_ranked + 1
      end
    end
    if imagined_moves[2] then organism.fitness.current_approval [wesnoth.current.side] = organism.fitness.current_approval [wesnoth.current.side] + 1 - ((2*higher_ranked)/(#imagined_moves-1)) end
  end
  
  this_scenario_moves = this_scenario_moves + 1
end

local hanging_move
local hanging_imagination
local resolve_hanging = function()
  if hanging_move then
    imagined_moves, hanging_imagination = hanging_imagination, imagined_moves
    move_completed (hanging_move)
    hanging_move = nil
    imagined_moves, hanging_imagination = hanging_imagination, nil
  end
end
on_side_turn = function ()
  imagine_moves()
end
on_side_turn_end = function ()
  resolve_hanging()
  if hidden_gold then wesnoth.sides [wesnoth.current.side].gold = hidden_gold end
end
on_moveto = function ()
  resolve_hanging()
  local unit = wesnoth.get_unit (wesnoth.current.event_context.x1,wesnoth.current.event_context.y1)
  local previous_unit = remembered_units [unit.id]
  hanging_move = {type = "move", unit = previous_unit, src_x = previous_unit.x, src_y = previous_unit.y, dst_x = unit.x, dst_y = unit.y}
  hanging_imagination = imagined_moves
  imagine_moves()
end
on_attack = function ()
  local unit = wesnoth.get_unit (wesnoth.current.event_context.x1,wesnoth.current.event_context.y1)
  local previous_unit = remembered_units [unit.id]
  local attack_move = {type = "attack", unit= unit, src_x = unit.x,src_y = unit.y,dst_x = wesnoth.current.event_context.x2,dst_y = wesnoth.current.event_context.y2, weapon = nil}
  if hanging_move and hanging_move.unit.id == unit.id then
    attack_move.unit = previous_unit
    hanging_move = attack_move  
    resolve_hanging()
  else
    resolve_hanging()
    move_completed (attack_move)
  end
end
on_attack_end = function ()
  imagine_moves()
end
on_recruit = function ()
  local unit = wesnoth.get_unit (wesnoth.current.event_context.x1,wesnoth.current.event_context.y1)
  move_completed ({type = "recruit", dst_x =wesnoth.current.event_context.x1, dst_y = wesnoth.current.event_context.y1, unit_type = unit.type})
  imagine_moves()
end

>>
[/lua]
[/event]

