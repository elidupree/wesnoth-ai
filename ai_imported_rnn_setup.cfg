[event]
name=preload
[lua]
code=<<--rnnpl
helper = wesnoth.require ("lua/helper.lua")
JSON = wesnoth.require ("~add-ons/wesnoth-ai/dkjson.lua")

error_message = function(msg)
  wesnoth.fire("wml_message", { logger="err", message=msg })
end

local alignments = {lawful = 1, chaotic = -1, neutral = 0}
local convert_unit = function (unit)
  local config = unit.__cfg
  local result = {
    x = unit.x, y = unit.y,
    side = unit.side,
    alignment = alignments [config.alignment] or 0,
    attacks_left = unit.attacks_left,
    canrecruit = unit.canrecruit,
    cost = config.cost,
    experience = unit.experience, hitpoints = unit.hitpoints,
    level = config.level, max_experience = unit.max_experience,
    max_hitpoints = unit.max_hitpoints, max_moves = unit.max_moves,
    moves = unit.moves,
    resting = unit.resting,
    slowed = unit.status.slowed or false,
    poisoned = unit.status.poisoned or false,
    not_living = unit.status.not_living or false,
    zone_of_control = config.zoc,
    defense = {},
    movement_costs = {},
    resistance = {},
    attacks = {},
  }
  for key, value in pairs (map.config.terrain_info) do
    result.defense [key] = wesnoth.unit_defense (unit, key)
    result.movement_costs [key] = wesnoth.unit_movement_cost (unit, key)
  end
  for key, value in pairs ({fire = true, cold = true, arcane = true, blade = true, pierce = true, impact = true}) do
    result.resistance [key] = wesnoth.unit_resistance (unit, key)
  end
  for attack in helper.child_range (config, "attack") do
    table.insert (result.attacks, {
      damage = attack.damage,
      number = attack.number,
      damage_type = attack.type,
      range = attack.range,
    })
  end
  return result
end


dump_map = function ()
  local width, height = wesnoth.get_map_size()
  map = {
    config = {
      unit_type_examples = {},
      terrain_info = {},
      factions = {},
    },
    width = width,
    height = height,
    locations = {},
    starting_locations = {},
  }
  for Y = 1, height do for X = 1, width do
    local terrain =wesnoth.get_terrain (X, Y)
    local info = wesnoth.get_terrain_info (terrain)
    map.config.terrain_info [terrain] = {
      castle = info.castle,
      keep = info.keep,
      village = info.village,
      healing = info.healing,
    }
    map.locations [X + (Y-1)*width] = {
      terrain = terrain,
      village_owner = wesnoth.get_village_owner (X, Y) or 0,
      unit = nil,
    }
  end end
  local do_unit_type = function (unit_type)
    map.config.unit_type_examples [unit_type] = convert_unit (wesnoth.create_unit ({type = unit_type, side = 1, random_traits = false, random_gender = false, generate_name = false}), map.config.terrain_info)
  end
  for faction in helper.child_range (wesnoth.game_config.era, "multiplayer_side") do
    if faction.recruit then
      local converted = {recruits = {}, leaders = {}}
      for recruit in string.gmatch (faction.recruit, "[^,]+") do
        do_unit_type (recruit)
        table.insert (converted.recruits, recruit)
      end
      for leader in string.gmatch (faction.leader, "[^,]+") do
        do_unit_type (leader)
        table.insert (converted.leaders, leader)
      end
      table.insert (map.config.factions, converted)
    end
  end
  for side in pairs (wesnoth.sides) do
    local location = wesnoth.get_starting_location (side)
    table.insert (map.starting_locations, location)
  end
  
  return map
end

dump_map()

error_message (JSON.encode (map))
current_organism = JSON.decode (wesnoth.dofile ("~add-ons/wesnoth-ai/generated_rnn.lua"))


local unit_size = 23
local location_size = 6

local neural_location = function (X, Y)
  local terrain = wesnoth.get_terrain (X, Y)
  local info = wesnoth.get_terrain_info (terrain)
  local result = {
    X, Y, info.keep and 1 or 0, info.castle and 1 or 0, info.village and 1 or 0, info.healing
  }
  return result
end
local neural_unit = function (unit)
  local terrain = wesnoth.get_terrain (unit.x, unit.y)
  local result = {
    unit.x, unit.y,
    unit.moves, unit.attacks_left,
    unit.hitpoints, (unit.max_experience - unit.experience),
    wesnoth.is_enemy (wesnoth.current.side, unit.side) and 0 or 1, unit.canrecruit and 1 or 0,
    unit.max_hitpoints, unit.max_moves,
    unit.slowed and 1 or 0, unit.poisoned and 1 or 0, unit.not_living and 1 or 0,
    unit.alignment,
    unit.zone_of_control and 1 or 0,
    unit.resistance.blade,
    unit.resistance.pierce,
    unit.resistance.impact,
    unit.resistance.fire,
    unit.resistance.cold,
    unit.resistance.arcane,
    unit.defense [terrain],
    unit.movement_costs [terrain],
  }
  return result
end

local unit_examples = {}
local neural_unit_type = function (type_name, X, Y)
  if not unit_examples [type_name] then
    unit_examples [type_name] = convert_unit (wesnoth.create_unit ({type = type_name, side = 1, random_traits = false, random_gender = false, generate_name = false}), {})
  end
  unit_examples [type_name].side = wesnoth.current.side
  unit_examples [type_name].x = X
  unit_examples [type_name].y = Y
  return neural_unit (unit_examples [type_name])
end

local inputs
inputs = {
  turn_started = {
    size = 4,
    generate = function ()
      local my_side = wesnoth.sides [wesnoth.current.side]
      local enemy = wesnoth.sides [(wesnoth.current.side % 2) + 1]
      return {my_side.gold, my_side.total_income, enemy.gold, enemy.total_income}
    end,
  },
  unit_added = {
    size = unit_size,
    generate = function (unit)
      return neural_unit (unit)
    end,
  },
  unit_removed = {
    size = unit_size,
    generate = function (unit)
      return neural_unit (unit)
    end,
  },
  move = {
    size = location_size + unit_size,
    generate = function (move)
      local result = {}
      --local terrain = wesnoth.get_terrain (move.dst_x,move.dst_y)
      for index, value in ipairs (neural_location (move.dst_x,move.dst_y)) do table.insert (result, value) end
      for index, value in ipairs (neural_unit (move.converted)) do table.insert (result, value) end
      return result
    end,
  },
  attack = {
    size = location_size*2 + unit_size*2 + 8,
    generate = function (attack)
      local defend_unit = wesnoth.get_unit (attack.attack_x, attack.attack_y)
      local attacker, defender = wesnoth.simulate_combat (attack.unit, attack.weapon or defend_unit, attack.weapon and defend_unit)
      local result = {
        attacker.hp_chance [0], defender.hp_chance [0],
        attack.unit.hitpoints - attacker.average_hp, defend_unit.hitpoints - defender.average_hp,
        attacker.slowed, attacker.poisoned, defender.slowed, defender.poisoned
      }
      for index, value in ipairs (neural_location (attack.dst_x, attack.dst_y)) do table.insert (result, value) end
      for index, value in ipairs (neural_location (attack.attack_x, attack.attack_y)) do table.insert (result, value) end
      for index, value in ipairs (neural_unit (attack.converted)) do table.insert (result, value) end
      for index, value in ipairs (neural_unit (convert_unit(defend_unit))) do table.insert (result, value) end
      return result
    end,
  },
  recruit = {
    size = unit_size,
    generate = function (recruit)
      return neural_unit_type (recruit.unit_type, recruit.dst_x, recruit.dst_y)
    end,
  },
}


local hyperbolic_tangent = function (value)
  return (math.exp (2*value) - 1)/(math.exp (2*value) + 1)
end

local multiply_into = function (input, output, matrix)
  if #input ~= matrix.input_size then
    error_message (#input ..",".. matrix.input_size)
    assert(false)
  end
  local output_size = matrix.output_size
  for index = 1, output_size do output [index] = output [index] or 0 end
  for input_index, input_value in ipairs (input) do
    for output_index, output_value in ipairs (output) do
      output [output_index] = output_value + input_value*matrix.weights [output_index + (input_index-1)*output_size]
    end
  end
end

local next_memory = function (organism, memory, input)
  local result = {layers = {}}
  for layer = 1, #organism.layer_sizes do
    local next_layer = {}
    local layer_weights = organism.weights_by_input [input.input_type] [layer]
    for index, value in ipairs (layer_weights.bias) do next_layer [index] = value end
    multiply_into (memory.layers [layer], next_layer, layer_weights.hidden_matrix)
    multiply_into ((layer == 1) and input.vector or result.layers [layer - 1], next_layer, layer_weights.input_matrix)
    for index, value in ipairs (next_layer) do
      next_layer [index] = hyperbolic_tangent (value)
    end
    result.layers [layer] = next_layer
  end
  return result
end

local initial_memory = function (organism)
  local result = {layers={}}
  for layer = 1, #organism.layer_sizes do
    local next_layer = {}
    for index=1,organism.layer_sizes[layer] do next_layer [index] = 0 end
    result.layers [layer] = next_layer
  end
  return result
end

local process_input = function (input_type, input)
  current_memory = next_memory (current_organism, current_memory, {input_type = input_type, vector = inputs [input_type].generate (input)})
end


evaluate = function (organism, memory, move)
  if move.type == "end_turn" then return 0 end
  local output = {}
  multiply_into (next_memory (organism, memory, {input_type = move.type, vector = inputs [move.type].generate (move)}).layers [#organism.layer_sizes], output, organism.output_weights)
  assert(output[1])
  return output[1]
end



local possible_unit_moves = function (unit, converted)
  local result = {}
    if unit.side == wesnoth.current.side then
      --error_message(inspect({"unit",unit.moves, #wesnoth.find_reach (unit)}))
      for whatever, reach_info in ipairs (wesnoth.find_reach (unit)) do
        local unit_there = wesnoth.get_unit(reach_info [1], reach_info [2])
        if not unit_there then
          table.insert (result , {type = "move", unit=unit,converted=converted, src_x = unit.x,src_y = unit.y,dst_x = reach_info [1],dst_y = reach_info [2]})
        end
        if not (unit_there and unit_there ~= unit) then
        
      if unit.attacks_left > 0 then
        for X, Y in helper.adjacent_tiles (reach_info [1], reach_info [2]) do
          local neighbor = wesnoth.get_unit (X, Y)
          if neighbor and neighbor.hitpoints > 0 and wesnoth.is_enemy(unit.side, neighbor.side) then
            local index = 0
            for i,attack in ipairs(converted.attacks) do
              index = index + 1
              local attack_move = {type = "attack", unit=unit,converted=converted, src_x = unit.x,src_y = unit.y, dst_x = reach_info [1],dst_y = reach_info [2],attack_x = X,attack_y = Y, weapon = index}
              table.insert (result , attack_move)
              break
            end
          end
        end
      end

        end
      end
      
      if unit.canrecruit and wesnoth.get_terrain_info (wesnoth.get_terrain (unit.x, unit.y)).keep then
        local castles = {}
        local frontier = {{unit.x, unit.y}}
        while frontier [1] do
          local current = frontier [#frontier]
          table.remove (frontier)
          for X, Y in helper.adjacent_tiles (current [1], current [2]) do
            if wesnoth.get_terrain_info (wesnoth.get_terrain (X, Y)).castle and not castles [X..","..Y] then
              castles [X..","..Y] = {X, Y}
              table.insert (frontier, {X, Y})
            end
          end
        end
        for key, value in pairs (castles) do
            if not wesnoth.get_unit (value [1], value [2]) then
              for i,recruit_type in ipairs(wesnoth.sides[wesnoth.current.side].recruit) do
                if wesnoth.unit_types[recruit_type].cost <= wesnoth.sides[wesnoth.current.side].gold then
                  table.insert (result , {type = "recruit", dst_x = value [1], dst_y = value [2], unit_type = recruit_type})
                end
              end
              for i,recruit_type in ipairs(unit.extra_recruit) do
                if wesnoth.unit_types[recruit_type].cost <= wesnoth.sides[wesnoth.current.side].gold then
                  table.insert (result , {type = "recruit", dst_x = value [1], dst_y = value [2], unit_type = recruit_type})
                end
              end
            end
        end
      end
    end
  
  return result

end


-- inputs [input_type].generate (input))
--inputs [input_type].generate (input))[layers]
 --[[   local unit = remembered_units[unit.id]
    for index, organism in ipairs (organisms) do
      process_input ("unit_added", unit)
    end
    ]]
calculate_moves = function()
  local width, height = wesnoth.get_map_size()
  for Y = 1, height do for X = 1, width do
    local unit = wesnoth.get_unit (X, Y)
    if unit and unit.side == wesnoth.current.side and not current_moves [X.."_"..Y] then
      current_moves [X.."_"..Y] = {}
      for index, move in ipairs (possible_unit_moves (unit, convert_unit(unit))) do
        current_moves [X.."_"..Y] [index] = {move, evaluate (current_organism, current_memory, move)}
      end
    end
  end end
end

collect_moves = function()
  calculate_moves()
  
  local results = {{{type = "end_turn"},0}}
  local width, height = wesnoth.get_map_size()
  for Y = 1, height do for X = 1, width do
    if current_moves [X.."_"..Y] then for index, move in ipairs (current_moves [X.."_"..Y]) do
      table.insert (results, move)
    end end
  end end
  
  return results
end

choose_move = function()
  local moves = collect_moves()
  table.sort (moves, function(a,b) return a[2] > b[2] end)
  return moves [1][1]
end

local remember_units = function()
  remembered_units = {}
  local units = wesnoth.get_units({})
  for I, unit in ipairs (units) do
    remembered_units [unit.id] = wesnoth.copy_unit (unit)
  end
end


scenario_began = function()
  current_memory = initial_memory(current_organism)
  remember_units()
end
on_turn_refresh = function ()
  process_input ("turn_started")
  current_moves = {}
  remember_units()
end
on_side_turn_end = function ()
  if hidden_gold then wesnoth.sides [wesnoth.current.side].gold = hidden_gold end
end
on_moveto = function ()
  local unit = wesnoth.get_unit (wesnoth.current.event_context.x1,wesnoth.current.event_context.y1)
  local previous_unit = remembered_units [unit.id]
  hanging_move = {type = "move", unit = previous_unit, src_x = previous_unit.x, src_y = previous_unit.y, dst_x = unit.x, dst_y = unit.y}
  hanging_imagination = imagined_moves
  remember_units()
end
on_attack = function ()
  local unit = wesnoth.get_unit (wesnoth.current.event_context.x1,wesnoth.current.event_context.y1)
  local previous_unit = remembered_units [unit.id]
  local attack_move = {type = "attack", unit= unit, src_x = unit.x,src_y = unit.y,dst_x = wesnoth.current.event_context.x2,dst_y = wesnoth.current.event_context.y2, weapon = nil}
  remember_units()
end
on_attack_end = function ()
  remember_units()
end
on_recruit = function ()
  local unit = wesnoth.get_unit (wesnoth.current.event_context.x1,wesnoth.current.event_context.y1)
  remember_units()
end

>>
[/lua]
[/event]

