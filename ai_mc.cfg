[ai]
  version=1071034
  [engine]
    name="lua"
    code= <<--mc_ai.cfg
--! ==============================================================
local helper = wesnoth.require("lua/helper.lua")

local builtin_ai_stuff = ...
local sampleable_persistent_set

local err_msg = function(msg)
  wesnoth.fire("wml_message", { logger="err", message=msg })
end

local timestamp = function()
  if wesnoth.get_time_stamp then return wesnoth.get_time_stamp() end
  wesnoth.fire("set_variable", {name="LUA_TEMP", time="stamp"})
  local result = wesnoth.get_variable("LUA_TEMP")
  wesnoth.set_variable("LUA_TEMP")
  return result
end

local shallow_copy = function(input)
  if type(input) ~= "table" then return input end
  local result = {}
  for k,v in pairs(input) do result[k]=v end
  return result
end

local set_to = function(val)
  return {val=val,is_with_updates_set_to=true}
end
local with_updates
with_updates = function(t, t_changes)
  local result = {}
  for k,v in pairs(t) do
    result[k] = v
  end
  for k,v_changes in pairs(t_changes) do
    if v_changes.is_with_updates_set_to then
      result[k] = v_changes.val
    else
      result[k] = with_updates(result[k], v_changes)
    end
  end
  return result
end

local get_sunit = function(state, x, y)
  return state.units_map[x][y]
end

local state_with_unit = function(state, x, y, sunit)
  local old_unit = get_sunit(state, x, y)
  local sides_updates = {}
  if old_unit then
    sides_updates[old_unit.wunit.side] = {}
    sides_updates[old_unit.wunit.side].units = set_to(  state.sides[old_unit.wunit.side].units.erase (old_unit))
  end
  if sunit then
    if not sides_updates[   sunit.wunit.side] then
      sides_updates[ sunit.wunit.side] = {}
      sides_updates[ sunit.wunit.side].units = set_to(  state.sides[   sunit.wunit.side].units.insert(   sunit))
    else
      sides_updates[ sunit.wunit.side].units = set_to(sides_updates[   sunit.wunit.side].units.val.insert(   sunit)) -- hack, TODO better
    end
  end
  return with_updates(state, {
    units_map={[x]={[y]=set_to(sunit)}},
    sides=sides_updates,
  })
end

local get_terrain = function(state, x, y)
  --return state.map[x][y].terrain
  return wesnoth.get_terrain(x,y)
end

local load_unit = function(wunit)
  local tunit = wunit.__cfg
  local attacks = {}
  local sunit = {
    wunit = wunit,
    hitpoints = wunit.hitpoints,
    moves = wunit.moves,
    attacks_left = wunit.attacks_left,
    attacks = attacks,
    x = wunit.x,
    y = wunit.y,
    weight = 1,
    choices = {}
  }
  for attack in helper.child_range(tunit, "attack") do
    table.insert(attacks, attack)
  end
  return sunit
end

local load_game_state = function()
  local units_map = {}
  local sides = {}
  local state = {
    whose_turn = wesnoth.current.side,
    units_map = units_map,
    sides = sides,
    moves = {},
  }
  
  for side,info in ipairs(wesnoth.sides) do
    sides[side] = {
      gold=info.gold,
      units = sampleable_persistent_set(),
    }
  end
  
  local w,h = wesnoth.get_map_size()
  for x=1,w do
    local col = {}
    units_map[x] = col
    
    for y=1,h do
      local wunit = wesnoth.get_unit(x,y)
      if wunit then
        local sunit = load_unit(wunit)
        col[y] = sunit
        sides[wunit.side].units = sides[wunit.side].units.insert(sunit)
      end
    end
  end
  
  return state
end

local priority_queue = function(priority_func)
  local function heap_insert(h,v,priority)
    h.size = h.size + 1
    if h.top_priority < priority then
      local temp = h.top
      local tempp = h.top_priority
      h.top = v
      h.top_priority = priority
      v = temp
      priority = tempp
    end
        if not h.child1 then h.child1 = {size=1,top=v,top_priority=priority}
    elseif not h.child2 then h.child2 = {size=1,top=v,top_priority=priority}
    else heap_insert((h.child1.size <= h.child2.size) and h.child1 or h.child2,v,priority) end
  end
  local function heap_pop(h)
    h.size = h.size - 1
    local child
        if not h.child1 then child = "child2"
    elseif not h.child2 then child = "child1"
    else child = (h.child1.top_priority > h.child2.top_priority) and "child1" or "child2" end
    h.top=h[child].top; h.top_priority=h[child].top_priority
    if h[child].size == 1 then h[child] = nil
    else heap_pop(h[child]) end
  end
  local heap
  return {
    insert = function(v,priority)
      priority = priority or (priority_func and priority_func(v) or v)
        if not heap then heap = {size=1,top=v,top_priority=priority}
      else heap_insert(heap, v, priority) end
    end,
    top = function() return heap and heap.top end,
    pop = function()
      if heap then
        local result = heap.top
        if heap.size == 1 then heap = nil
        else heap_pop(heap) end
        return result
      end
    end,
  }
end

do -- do sampleable_persistent_set_impl
local node_min = 3
local node_max = 6
local last_desc
last_desc = function(node)
  if node.children then return last_desc(node.children[#node.children]) else return node.here[#node.here] end
end
local recalc_weight = function(node)
  node.total_weight = 0
  for i,here in ipairs(node.here) do
    node.total_weight = node.total_weight + here.weight
  end
  if node.children then for i,child in ipairs(node.children) do
    node.total_weight = node.total_weight + child.total_weight
  end end
end
local insert_impl
insert_impl = function(node, e)
  local right_of = 0
  
  for i,here in ipairs(node.here) do
    if here.sampleable_persistent_set_idx == e.sampleable_persistent_set_idx then
      local new_node = {
        here=shallow_copy(node.here),
        children=shallow_copy(node.children),
      }
      new_node.here[i] = e
      recalc_weight(new_node)
      return {new_node}
    end
    if here.sampleable_persistent_set_idx < e.sampleable_persistent_set_idx then
      right_of = i
    end
  end
  
  local new_children = shallow_copy(node.children)
  local new_here = shallow_copy(node.here)
  local new_node = {here=new_here,children=new_children}
  local result = {new_node}
  if node.children then
    local child = node.children[right_of+1]
    local sub_result = insert_impl(child, e)
    new_children[right_of+1] = sub_result[1]
    if sub_result[2] then
      table.insert(new_here, right_of+1, sub_result[2])
      table.insert(new_children, right_of+1+1, sub_result[3])
    end
  else
    table.insert(new_here, right_of+1, e)
  end
  
  local num_new_here = #new_here
  if num_new_here > node_max then
    local medidx = math.ceil(num_new_here / 2)
    local new_children_2 = new_children and {}
    local new_here_2 = {}
    result[2] = new_here[medidx]
    new_here[medidx] = nil
    result[3] = {here=new_here_2,children=new_children_2}
    for i=medidx+1,num_new_here do
      table.insert(new_here_2, new_here[i])
      new_here[i] = nil
      if new_children_2 then
        table.insert(new_children_2, new_children[i])
        new_children[i] = nil
      end
    end
    recalc_weight(result[3])
  end
  recalc_weight(new_node)
  return result
end
local erase_impl
erase_impl = function(node, e)
  local right_of = 0
  
  for i,here in ipairs(node.here) do
    if here.sampleable_persistent_set_idx == e.sampleable_persistent_set_idx then
      local new_node = {
        here=shallow_copy(node.here),
        children=shallow_copy(node.children),
      }
      if node.children then
        local replacement = last_desc(node.children[i])
        new_node.here[i] = replacement
        new_node.children[i] = erase_impl(node.children[i], replacement)
        recalc_weight(new_node)
        return new_node
      else
        -- TODO proper algo
        table.remove(new_node.here, i)
        recalc_weight(new_node)
        return new_node
      end
    end
    if here.sampleable_persistent_set_idx < e.sampleable_persistent_set_idx then
      right_of = i
    end
  end
  
  local child = node.children[right_of+1]
  local sub_result = erase_impl(child, e)
  local new_children = shallow_copy(node.children)
  local new_here = shallow_copy(node.here)
  local new_node = {here=new_here,children=new_children}
  new_children[right_of+1] = sub_result
  recalc_weight(new_node)
  return new_node
end

local sample_impl
sample_impl = function(node)
  local choice = math.random() * node.total_weight
  for i,here in ipairs(node.here) do
    if node.children then
      choice = choice - node.children[i].total_weight
      if choice < 0 then return sample_impl(node.children[i]) end
    end
    choice = choice - here.weight
    if choice < 0 then return here end
  end
  if node.children then
    return sample_impl(node.children[#node.children])
  else
    return node.here[#node.here]
  end
end
  
local next_index = 1
sampleable_persistent_set = function(root)
  local values = function()
    local stack
    local advance_here
    local climb_both
    local climb_down
    advance_here = function()
      stack.which_here = stack.which_here + 1
      local result = stack.node.here[stack.which_here]
      if result then return result else return climb_both() end
    end
    climb_both = function()
      local next_child
      repeat
        stack = stack.parent
        if not stack then return end
        stack.which_child = stack.which_child + 1
        local next_child = stack.node.children[stack.which_child]
      until next_child
      stack.node = next_child
      return climb_down()
    end
    climb_down = function()
      while stack.node.children do
        stack = {
          parent = stack,
          node = stack.node.children[1],
          which_child = 1,
          which_here = 0,
        }
      end
      return advance_here()
    end
    return function()
      if not stack then
        if not root then return end
        stack = {
          node = root,
          which_child = 1,
          which_here = 0,
        }
        return climb_down()
      else
        return advance_here()
      end
    end
  end
  return {
    insert = function(e)
--       err_msg("before")
--       for v in values() do err_msg(v.sampleable_persistent_set_idx) end
      if not e.sampleable_persistent_set_idx then
        e.sampleable_persistent_set_idx = next_index
        next_index = next_index + 1
      end
--       err_msg("inserting")
--       err_msg(e.sampleable_persistent_set_idx)
      local new_root
      if not root then
        new_root = {here={e}}
        recalc_weight(new_root)
      else
        local sub_result = insert_impl(root, e)
        if sub_result[2] then
          new_root = {here={sub_result[2]},children={sub_result[1],sub_result[3]}}
          recalc_weight(new_root)
        else
          new_root = sub_result[1]
        end
      end
      local result = sampleable_persistent_set(new_root)
--       err_msg("after")
--       for v in result.values() do err_msg(v.sampleable_persistent_set_idx) end
      return result
    end,
    erase = function(e)
--       err_msg("before")
--       for v in values() do err_msg(v.sampleable_persistent_set_idx) end
--       err_msg("erasing")
--       err_msg(e.sampleable_persistent_set_idx)
      local new_root = erase_impl(root, e)
      local result = sampleable_persistent_set(new_root)
--       err_msg("after")
--       for v in result.values() do err_msg(v.sampleable_persistent_set_idx) end
      return result
    end,
    sample = function() return root and sample_impl(root) end,
    values = values,
  }
end
end -- do sampleable_persistent_set_impl

local find_reach = function(x1,y1,cost_func,maximum,zoc_side,state)
  local result = {}
  local frontier = priority_queue(function(hex) return -hex.cost end)
  local found_hexes = {}
  local reach_hex = function(x,y,cost)
    if not (maximum and (cost > maximum)) then
      local sunit
      local zocd = false
      if zoc_side then
        sunit = get_sunit(state,x,y)
        if cost > 0 then
          for x2,y2 in helper.adjacent_tiles(x, y) do
            local sunit = get_sunit(state,x2,y2)
            if sunit and wesnoth.is_enemy(zoc_side, sunit.wunit.side) then -- TODO units without zoc
              zocd = true
            end
          end
        end
      end
      if (not zoc_side) or (not sunit) then table.insert(result, {x=x,y=y,cost=zocd and maximum or cost}) end
      if (not zoc_side) or (not sunit) or (not wesnoth.is_enemy(zoc_side, sunit.wunit.side)) and not zocd then frontier.insert({x=x,y=y,cost=cost}) end
    end
  end
  local find_hex = function(x,y,old_cost)
    local idx = x..","..y
    if not found_hexes[idx] then
      found_hexes[idx] = true
      if old_cost then
        local cost = 1
        if cost_func then cost = cost_func(x,y,old_cost) end
        if cost then reach_hex(x,y,old_cost + cost) end
      else
        reach_hex(x,y,0)
      end
    end
  end
  find_hex(x1,y1)
  while frontier.top() do
    local start = frontier.pop()
    for x,y in helper.adjacent_tiles(start.x, start.y) do
      find_hex(x,y,start.cost)
    end
  end
  return result
end

local find_unit_reach = function(state,x1,y1,sunit)
  local cost = function(x,y)
    return wesnoth.unit_movement_cost(sunit.wunit, get_terrain(state, x, y))
  end
  return find_reach(x1,y1, cost, sunit.moves, sunit.wunit.side, state)
end

local serialize_move = function(move)
  return move.type..","..(move.src and (move.src.x..","..move.src.y..",") or "")..(move.dst and (move.dst.x..","..move.dst.y..",") or "")..(move.weapon and (move.weapon..",") or "")..(move.unit_type and (move.unit_type..",") or "")
end

local random_move = function(node)
  local w,h = wesnoth.get_map_size()
  local units = node.sides[node.whose_turn].units
  local sunit = units.sample()
  local units_map = node.units_map
  local init_move = function(move)
    move.priority = 0
    move.times_tried = 0
    move.before = node
    move.serialized = serialize_move(move)
    return move
  end
  local chosen_move = init_move{type="end_turn", weight = 0.1}
  if sunit then
    local choices = sunit.choices[node]
    if not choices then
      choices = sampleable_persistent_set()
      local make_move = function(move)
        choices = choices.insert(init_move(move))
      end
      if sunit.attacks_left > 0 then
        for x2,y2 in helper.adjacent_tiles(sunit.x,sunit.y) do
          local sunit2 = get_sunit(node,x2,y2)
          if sunit2 and wesnoth.is_enemy(sunit2.wunit.side, sunit.wunit.side) then
            for i in ipairs(sunit.attacks) do
              make_move({
                type="attack",
                src = {x=sunit.x,y=sunit.y},
                dst = {x=x2,y=y2},
                weapon = i,
                weight = 10,
              })
            end
          end
        end
      end
      if sunit.moves > 0 then
        local reach = find_unit_reach(node, sunit.x, sunit.y, sunit)
        for i,hex in ipairs(reach) do
          make_move({
            type="move",
            src = {x=sunit.x,y=sunit.y},
            dst = hex,
            weight = (hex.cost == sunit.moves) and 1 or 0.1,
          })
        end
      end
      if sunit.wunit.canrecruit and wesnoth.get_terrain_info(get_terrain(node, sunit.x, sunit.y)).keep then
        for i,recruit_dst in ipairs(find_reach(sunit.x,sunit.y,function(x, y)
                  return wesnoth.get_terrain_info(get_terrain(node, x, y)).castle and 1 or nil
                end)) do
          if not get_sunit(node, recruit_dst.x, recruit_dst.y) then
            for i,recruit_type in ipairs(wesnoth.sides[node.whose_turn].recruit) do
              if wesnoth.unit_types[recruit_type].cost <= node.sides[node.whose_turn].gold then
                make_move({ type = "recruit", dst = recruit_dst, unit_type = recruit_type, weight = 10 })
              end
            end
            for i,recruit_type in ipairs(sunit.wunit.extra_recruit) do
              if wesnoth.unit_types[recruit_type].cost <= sim.gold then
                make_move({ type = "recruit", dst = recruit_dst, unit_type = recruit_type, weight = 10 })
              end
            end
          end
        end
      end
      sunit.choices[node] = choices
    end
    chosen_move = choices.sample() or chosen_move
  end
  local already = node.moves[chosen_move.serialized]
  if already then
    return already
  else
    node.moves[chosen_move.serialized] = chosen_move
    return chosen_move
  end
end

local best_move = function(node)
  local best
  for k,move in pairs(node.moves) do
    if (not best) or (move.priority > best.priority) then
      best = move
    end
  end
  return best
end

local generate_move_result_by_type = {
  end_turn = function(state, move)
    local new_turn = state.whose_turn + 1
    if new_turn > #wesnoth.sides then
      new_turn = 1
    end
    local updates = {
      units_map = {},
      whose_turn = set_to(new_turn),
      sides = {},
    }
    -- TODO: income, healing
    local new_units = sampleable_persistent_set()
    for sunit in state.sides[new_turn].units.values() do
      local new_sunit = shallow_copy(sunit)
      new_sunit.moves = new_sunit.wunit.max_moves
      new_sunit.attacks_left = 1
      if not updates.units_map[new_sunit.x] then updates.units_map[new_sunit.x] = {} end
      updates.units_map[new_sunit.x][new_sunit.y] = set_to(new_sunit)
      new_units = new_units.insert(new_sunit)
    end
    updates.sides[new_turn] = { units = set_to(new_units) }
    return with_updates(state, updates)
  end,
  move = function(state, move)
    local sunit = shallow_copy(get_sunit(state, move.src.x, move.src.y))
    sunit.moves = sunit.moves - move.dst.cost
    sunit.x = move.dst.x
    sunit.y = move.dst.y
    return state_with_unit(state_with_unit(state, move.src.x, move.src.y, nil), move.dst.x, move.dst.y, sunit)
  end,
  attack = function(state, move)
    local a = {x=move.src.x, y=move.src.y}
    local d = {x=move.dst.x, y=move.dst.y}
    for i,c in ipairs({a,d}) do
      c.sunit = shallow_copy(get_sunit(state, c.x, c.y))
      c.defense = wesnoth.unit_defense(c.sunit.wunit, get_terrain(state, c.x, c.y))
    end
    a.sunit.moves = 0
    a.sunit.attacks_left = a.sunit.attacks_left - 1
    a.sunit.weight = 0
    a.weapon = a.sunit.attacks[move.weapon]
    for i,w in ipairs(d.sunit.attacks) do
      if w.range == a.weapon.range then d.weapon = w end --TODO...
    end
    for i,c in ipairs({a,d}) do
      c.swings = c.weapon and c.weapon.number or 0
    end
    local over = false
    swing = function(h,v)
      if math.random(1,100) > v.defense then
        v.sunit.hitpoints = v.sunit.hitpoints - h.weapon.damage
        h.swings = h.swings - 1
        if v.sunit.hitpoints <= 0 then v.sunit = nil; over = true end
      end
    end
    while a.swings > 0 and d.swings > 0 and not over do
      if a.swings > 0 and not over then swing(a,d) end
      if d.swings > 0 and not over then swing(d,a) end
    end
    return state_with_unit(state_with_unit(state, move.src.x, move.src.y, a.sunit), move.dst.x, move.dst.y, d.sunit)
  end,
  recruit = function(state, move)
    local sunit = load_unit(wesnoth.create_unit({
      x=move.dst.x,
      y=move.dst.y,
      side=state.whose_turn,
      type=move.unit_type,
      moves=0,
      attacks_left=0,
      generate_name=false,
      random_traits=false,
      random_gender=false,
    }))
    -- TODO: traits
    local updates = {
      sides = { [state.whose_turn] = { gold = set_to(state.sides[state.whose_turn].gold - wesnoth.unit_types[move.unit_type].cost) } }
    }
    return state_with_unit(with_updates(state, updates), move.dst.x, move.dst.y, sunit)
  end,
}
local generate_move_result = function(state, move)
  local new_state = generate_move_result_by_type[move.type](state, move)
  new_state.last_move = move
  new_state.moves = {}
  return new_state
end

local deterministic_move_types = {move=true,end_turn=true}
local move_is_deterministic = function(move)
  return deterministic_move_types[move] or false
end

local playout_result_from = function(node)
  local results_func = function()
    local sides_with_leaders = {}
    local w,h = wesnoth.get_map_size()
    local units_map = node.units_map
    for x=1,w do
      local col = units_map[x]
      for y=1,h do
        local sunit = col[y]
        if sunit and sunit.wunit.canrecruit then
          sides_with_leaders[sunit.wunit.side] = true
        end
      end
    end
    for side1 in pairs(sides_with_leaders) do
      for side2 in pairs(sides_with_leaders) do
        if wesnoth.is_enemy(side1, side2) then return nil end
      end
    end
    return {winners = sides_with_leaders}
  end
  
  local num_moves = 0
  local before_playout = timestamp()
--   err_msg("begin playout")
  while true do
    local move = random_move(node)
--     err_msg(serialize_move(move))
    node = generate_move_result(node, move)
    local results = results_func()
    num_moves = num_moves + 1
    local now = timestamp()
    if results then
--       err_msg("playout succeeded")
      return results
    end
    if num_moves > 2000 then
      err_msg("playout took more than 2000 moves, aborting")
      return {winners={}}
    end
    if (now - before_playout) > 50 then
      err_msg("playout took more than 50ms, aborting")
      return {winners={}}
    end
  end
end

local mc_iteration = function(mc_tree)
  local node = mc_tree
  while true do
    local move = random_move(node)
    move.times_tried = move.times_tried + 1
    if move_is_deterministic(move) then
      if not move.after then
        move.after = generate_move_result(node, move)
      end
      node = move.after
    else
      if not move.after then
        move.after = {}
      end
      -- TODO: for recruits, stop after generating all trait combos
      if (not move.after[1]) or ((#move.after) < math.log(move.times_tried)) then
        table.insert(move.after, generate_move_result(node, move))
      end
      node = move.after[math.random(1, #move.after)]
    end
    if move.times_tried == 1 then break end
  end
  local result = playout_result_from(node)
  
  while true do
    local move = node.last_move
    if not move then break end
    local prev_node = move.before
    move.priority = ((move.priority*(move.times_tried-1)) + (result.winners[prev_node.whose_turn] and 1 or 0)) / move.times_tried
    node = prev_node
  end
end

local do_move_by_type = {
  move = function(move) builtin_ai_stuff.move(move.src.x, move.src.y, move.dst.x, move.dst.y) end,
  attack = function(move) builtin_ai_stuff.attack(move.src.x, move.src.y, move.dst.x, move.dst.y, move.weapon-1) end,
  recruit = function(move) builtin_ai_stuff.recruit(move.unit_type, move.dst.x, move.dst.y) end,
  end_turn = function() return true end,
}
local do_move = function(move)
  return not do_move_by_type[move.type](move)
end

local calculate_and_do_one_move = function()
  local before_loading = timestamp()
  local state = load_game_state()
  local after_loading = timestamp()
  local mc_tree = state
  local mc_iterations = 0
  while true do
    mc_iteration(mc_tree)
    mc_iterations = mc_iterations + 1
    local after_mc_iteration = timestamp()
    if (mc_iterations > 5000) or ((after_mc_iteration - after_loading) > 2000) then
      err_msg(""..(after_loading-before_loading).."ms loading, "..(after_mc_iteration - after_loading).."ms doing "..mc_iterations.." iterations (playouts).")
      break
    end
  end
  return do_move(best_move(mc_tree))
end

local our_ai = { }
function our_ai:do_moves()
  while calculate_and_do_one_move() do end
end

return our_ai
--! ==============================================================
>>
  [/engine]
  [stage]
    engine="lua"
    code="(...):do_moves()"
  [/stage]
[/ai]

