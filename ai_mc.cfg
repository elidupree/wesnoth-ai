[ai]
  version=1071034
  [engine]
    name="lua"
    code= <<--mc_ai.cfg
--! ==============================================================
local helper = wesnoth.require("lua/helper.lua")

local builtin_ai_stuff = ...
local sampleable_persistent_set
local sampleable_mutable_set
local generate_move_result
local evaluate

local deterministic_move_types = {move=true,end_turn=true,recruit=true} -- TODO: traits
local move_is_deterministic = function(move)
  return deterministic_move_types[move.type] or false
end


local pack = function(...) return {...} end
local profiling_stack
local profiling = {}
local profile_func = function(name, func)
  --if true then return func end
  return function(...)
    local stack_name = profiling_stack and profiling_stack.stack_name.."."..name or "stack: "..name
    profiling_stack = { func_name = name, stack_name = stack_name, up = profiling_stack }
    local prof = profiling[name] or {}
    profiling[name] = prof
    local sprof = profiling[stack_name] or {}
    profiling[stack_name] = sprof
    sprof.calls = (sprof.calls or 0) + 1
    sprof.incl = (sprof.incl or 0)
    sprof.self = (sprof.self or 0)
    prof.calls = (prof.calls or 0) + 1
    prof.incl = (prof.incl or 0)
    prof.self = (prof.self or 0)
    local cl1 = os.clock()
    local results = pack(func(...))
    local cl2 = os.clock()
    prof.incl = prof.incl + (cl2 - cl1)
    prof.self = prof.self + (cl2 - cl1)
    sprof.incl = sprof.incl + (cl2 - cl1)
    sprof.self = sprof.self + (cl2 - cl1)
    profiling_stack = profiling_stack.up
    if profiling_stack then
      local up_prof = profiling[profiling_stack.func_name]
      local up_sprof = profiling[profiling_stack.stack_name]
      up_prof.self = up_prof.self - (cl2 - cl1)
      up_sprof.self = up_sprof.self - (cl2 - cl1)
    end
    return unpack(results)
  end
end
do
  local foo = function(f) wesnoth[f] = profile_func("w!"..f, wesnoth[f]) end
  foo("fire"); foo("get_terrain"); foo("get_terrain_info"); foo("is_enemy"); foo("unit_movement_cost");
  foo("create_unit"); foo("get_map_size"); foo("unit_resistance"); foo("unit_defense");
  table.insert = profile_func("table!insert", table.insert)
end

dump_profiling = function()
  local cropnum = function(n)
    return string.format("%.3f", n)
  end
  
  local dot = {"\n\n\n\n\n\n\n\n\n\ndigraph Prof {\n"}
  for k,v in pairs(profiling) do
    if v.incl > 0.005 then
      local stack = string.match(k, "^stack: (.+)$")
      if stack then
        local up,here = string.match(stack, "^(.+)%.([^.]-)$")
        if not here then here = stack end
        table.insert(dot,'"'..stack..'"[label=<'..here..'<BR/>'..cropnum(v.incl)..', '..cropnum(v.self)..', '..v.calls..'>]\n')
        if up then 
          table.insert(dot,'"'..up..'" -> "'..stack..'"\n')
        end
      end
    end
  end
  table.insert(dot, "}\n\n\n\n\n\n\n\n\n\n")
  wesnoth.fire("wml_message", { logger="err", message=table.concat(dot) })
end

dump_tree = function(tree, depth)
  local cropi = function(n)
    return n and string.format("%d", n) or "nil"
  end
  local cropf = function(n)
    return n and string.format("%.3f", n) or "nil"
  end
  local dot = {"\n\n\n\n\n\n\n\n\n\ndigraph Tree {\n"}
  local n = 1
  local desc
  local descm
  desc = function(node, up, d)
    local here = "node"..n
    n=n+1
    if up then table.insert(dot,'"'..up..'" -> "'..here..'"\n') end
    local l = "n"
    table.insert(dot,'"'..here..'"[label=<'..l..'<BR/>'..cropi(node.times_entered)..', '..cropf(evaluate(node)[node.whose_turn])..'>]\n')
    if node.move_choices then
      for move in node.move_choices.values() do descm(move, here, d) end
    end
  end
  descm = function(move, up, d)
    local here = "move"..n
    n=n+1
    table.insert(dot,'"'..up..'" -> "'..here..'"\n')
    local l = move.serialized
    table.insert(dot,'"'..here..'"[label=<'..l..'<BR/>'..cropi(move.times_tried)..', '..cropf(move.weight)..'>]\n')
    if move.after and (d < depth) then
      if move_is_deterministic(move) then
        desc(move.after, here, d+1)
      else
        for i,node in ipairs(move.after) do desc(node, here, d+1) end
      end
    end
  end
  desc(tree, nil, 1)
  table.insert(dot, "}\n\n\n\n\n\n\n\n\n\n")
  wesnoth.fire("wml_message", { logger="err", message=table.concat(dot) })
end


local err_msg = function(msg)
  wesnoth.fire("wml_message", { logger="err", message=msg })
end

local timestamp = function()
  if wesnoth.get_time_stamp then return wesnoth.get_time_stamp() end
  wesnoth.fire("set_variable", {name="LUA_TEMP", time="stamp"})
  local result = wesnoth.get_variable("LUA_TEMP")
  wesnoth.set_variable("LUA_TEMP")
  return result
end

local shallow_copy = function(input)
  if type(input) ~= "table" then return input end
  local result = {}
  for k,v in pairs(input) do result[k]=v end
  return result
end
shallow_copy = profile_func("shallow_copy", shallow_copy)

-- half-persistent state system

local hpss_copy = function(t)
  local result = shallow_copy(t)
  result.hpss_prev = t
  return result
end
local hpss_index = function(t, idx)
  local result = t[idx]
  if type(result) ~= "table" then return result end
  if t.hpss_prev and (result == t.hpss_prev[idx]) then
    result = hpss_copy(result)
    t[idx] = result
  end
  assert(((not t.hpss_prev) and not result.hpss_prev) or (result.hpss_prev == t.hpss_prev[idx]))
  return result
end

local get_sunit = function(state, x, y)
  return state.units_map[x][y]
end

local require_tf = function(t, f)
  local r = t[f]
  if not r then r = {}; t[f] = r end
  return r
end
local remove_map_unit = function(state, x, y)
  hpss_index(hpss_index(state, "units_map"), x)[y] = nil
  assert (get_sunit(state, x, y) == nil)
end
remove_map_unit = profile_func("remove_map_unit", remove_map_unit)
local remove_unit = function(state, x, y)
  local old_sunit = get_sunit(state, x, y)
  remove_map_unit(state, x, y)
  local side = hpss_index(hpss_index(state, "sides"), old_sunit.side)
  side.units = side.units.erase(old_sunit)
end
remove_unit = profile_func("remove_unit", remove_unit)
local set_unit = function(state, sunit)
  assert (sunit.tunit)
  hpss_index(hpss_index(state, "units_map"), sunit.x)[sunit.y] = sunit
  local side = hpss_index(hpss_index(state, "sides"), sunit.side)
  side.units = side.units.insert(sunit)
  assert (get_sunit(state, sunit.x, sunit.y) == sunit)
end
set_unit = profile_func("set_unit", set_unit)

local get_terrain = function(state, x, y)
  --return state.map[x][y].terrain
  return wesnoth.get_terrain(x,y)
end

local load_unit = function(wunit)
  local tunit = wunit.__cfg
  local attacks = {}
  local sunit = {
    wunit = wunit,
    tunit = tunit,
    hitpoints = wunit.hitpoints,
    moves = wunit.moves,
    attacks_left = wunit.attacks_left,
    attacks = attacks,
    x = wunit.x,
    y = wunit.y,
    side = wunit.side,
    weight = 1,
    choices_determined_for = {},
    resistance = helper.get_child(tunit, "resistance"),
  }
  for attack in helper.child_range(tunit, "attack") do
    table.insert(attacks, attack)
  end
  return sunit
end
load_unit = profile_func("load_unit", load_unit)

local recruit_suint_prototypes = {}
local load_recruit = function(unit_type, side, x, y)
  local prototype = recruit_suint_prototypes[unit_type]
  if not prototype then
    prototype = load_unit(wesnoth.create_unit({
      x=1,
      y=1,
      side=1,
      type=unit_type,
      moves=0,
      attacks_left=0,
      generate_name=false,
      random_traits=false,
      random_gender=false,
    }))
    recruit_suint_prototypes[unit_type] = prototype
  end
  local result = shallow_copy(prototype)
  result.x = x
  result.y = y
  result.side = side
  return result
end
load_recruit = profile_func("load_recruit", load_recruit)

local load_game_state = function()
  local units_map = {}
  local sides = {}
  assert (wesnoth.current.side == builtin_ai_stuff.side)
  local state = {
    whose_turn = wesnoth.current.side,
    units_map = units_map,
    sides = sides,
    turn = {move_choices = {}},
    total_moves = 0,
  }
  
  for side,info in ipairs(wesnoth.sides) do
    sides[side] = {
      gold=info.gold,
      units = sampleable_persistent_set(),
    }
  end
  
  local w,h = wesnoth.get_map_size()
  for x=1,w do
    local col = {}
    units_map[x] = col
    
    for y=1,h do
      local wunit = wesnoth.get_unit(x,y)
      if wunit then
        local sunit = load_unit(wunit)
        col[y] = sunit
        sides[sunit.side].units = sides[sunit.side].units.insert(sunit)
      end
    end
  end
  
  return state
end
load_game_state = profile_func("load_game_state", load_game_state)

local priority_queue = function(priority_func)
  local function heap_insert(h,v,priority)
    h.size = h.size + 1
    if h.top_priority < priority then
      local temp = h.top
      local tempp = h.top_priority
      h.top = v
      h.top_priority = priority
      v = temp
      priority = tempp
    end
        if not h.child1 then h.child1 = {size=1,top=v,top_priority=priority}
    elseif not h.child2 then h.child2 = {size=1,top=v,top_priority=priority}
    else heap_insert((h.child1.size <= h.child2.size) and h.child1 or h.child2,v,priority) end
  end
  local function heap_pop(h)
    h.size = h.size - 1
    local child
        if not h.child1 then child = "child2"
    elseif not h.child2 then child = "child1"
    else child = (h.child1.top_priority > h.child2.top_priority) and "child1" or "child2" end
    h.top=h[child].top; h.top_priority=h[child].top_priority
    if h[child].size == 1 then h[child] = nil
    else heap_pop(h[child]) end
  end
  local heap
  return {
    insert = profile_func("pq_insert", function(v,priority)
      priority = priority or (priority_func and priority_func(v) or v)
        if not heap then heap = {size=1,top=v,top_priority=priority}
      else heap_insert(heap, v, priority) end
    end),
    top = function() return heap and heap.top end,
    pop = profile_func("pq_pop", function()
      if heap then
        local result = heap.top
        if heap.size == 1 then heap = nil
        else heap_pop(heap) end
        return result
      end
    end),
  }
end

do -- do sampleable_persistent_set_impl
local node_max = 16

local heaviest_impl
local inspect_impl

local last_desc
last_desc = function(node)
  if node.children then return last_desc(node.children[#node.children]) else return node.here[#node.here] end
end
local validate = function(node)
  if node.children then
    assert(#node.children == (#node.here + 1))
    for i,child in ipairs(node.children) do
      assert(node.heaviest >= child.heaviest)
    end
  end
  if node.here[1] then
    assert(heaviest_impl(node).weight == node.heaviest)
  end
end
local recalc_weight = function(node)
  node.total_weight = 0
  node.heaviest = -math.huge
  for i,here in ipairs(node.here) do
    node.total_weight = node.total_weight + here.weight
    node.heaviest = math.max(node.heaviest, here.weight)
  end
  if node.children then for i,child in ipairs(node.children) do
    node.total_weight = node.total_weight + child.total_weight
    node.heaviest = math.max(node.heaviest, child.heaviest)
  end end
  validate(node)
end
local update_member_weight = function(e)
  local change = e.weight - e.sampleable_persistent_set_old_weight
  local node = e.sampleable_persistent_set_node
  while node do
--   err_msg("test "..e.weight..", "..e.sampleable_persistent_set_old_weight.."\n"..inspect_impl(node))
    node.total_weight = node.total_weight + change
    if e.weight > node.heaviest then node.heaviest = e.weight end
    if e.sampleable_persistent_set_old_weight == node.heaviest then recalc_weight(node) end
--   err_msg("then "..e.weight..", "..e.sampleable_persistent_set_old_weight.."\n"..inspect_impl(node))
    
  validate(node)
    node = node.parent
  end
  e.sampleable_persistent_set_old_weight = e.weight
end
inspect_impl = function(node, depth)
  local real_depth = 0
  local p = node.parent
  while p do
    real_depth = real_depth + 1
    p = p.parent
  end

  depth = depth or 0
  local result = {string.rep(" ", depth*2), real_depth..", "..node.total_weight..", "..node.heaviest.." {\n"}
  for i,here in ipairs(node.here) do
    if node.children then
      table.insert(result, inspect_impl(node.children[i], depth+1))
    end
    table.insert(result, string.rep(" ", 2+depth*2)..here.sampleable_persistent_set_idx.." ("..here.weight.."/"..here.sampleable_persistent_set_old_weight.."),\n")
  end
  if node.children then
    table.insert(result, inspect_impl(node.children[#node.children], depth+1))
  end
  table.insert(result, string.rep(" ", depth*2).."}\n")
  return table.concat(result)
end
local insert_impl
insert_impl = function(node, e, persistent)
  local right_of = 0
  local new_node = persistent and {
    here=shallow_copy(node.here),
    children=shallow_copy(node.children),
  } or node
  
  for i,here in ipairs(node.here) do
    if here.sampleable_persistent_set_idx == e.sampleable_persistent_set_idx then
      new_node.here[i] = e
      if not persistent then assert(e.sampleable_persistent_set_node == new_node) end
      recalc_weight(new_node)
      return {new_node}
    end
    if here.sampleable_persistent_set_idx < e.sampleable_persistent_set_idx then
      right_of = i
    end
  end
  
  local new_children = new_node.children
  local new_here = new_node.here
  local result = {new_node}
  if node.children then
    local child = node.children[right_of+1]
    local sub_result = insert_impl(child, e)
    new_children[right_of+1] = sub_result[1]
    if sub_result[2] then
      assert(sub_result[2].sampleable_persistent_set_node == sub_result[1])
      sub_result[2].sampleable_persistent_set_node = new_node
      table.insert(new_here, right_of+1, sub_result[2])
      table.insert(new_children, right_of+1+1, sub_result[3])
    end
  else
    table.insert(new_here, right_of+1, e)
    if not persistent then
      assert(e.sampleable_persistent_set_node == nil)
      e.sampleable_persistent_set_node = new_node
    end
  end
  
  local num_new_here = #new_here
  if num_new_here > node_max then
    local medidx = math.ceil(num_new_here / 2)
    local new_children_2 = new_children and {}
    local new_here_2 = {}
    result[2] = new_here[medidx]
    new_here[medidx] = nil
    result[3] = {here=new_here_2,children=new_children_2}
    for i=medidx+1,num_new_here+1 do
      table.insert(new_here_2, new_here[i])
      if new_here[i] and not persistent then
        assert(new_here[i].sampleable_persistent_set_node == new_node)
        new_here[i].sampleable_persistent_set_node = result[3]
      end
      new_here[i] = nil
      if new_children_2 then
        table.insert(new_children_2, new_children[i])
        new_children[i] = nil
      end
    end
    if not persistent then result[3].parent = new_node.parent end
    recalc_weight(result[3])
  end
  recalc_weight(new_node)
  return result
end
local erase_impl
erase_impl = function(node, e, persistent)
  assert (persistent)
  local right_of = 0
  
  for i,here in ipairs(node.here) do
    if here.sampleable_persistent_set_idx == e.sampleable_persistent_set_idx then
      local new_node = {
        here=shallow_copy(node.here),
        children=shallow_copy(node.children),
      }
      if node.children then
        local replacement = last_desc(node.children[i])
        new_node.here[i] = replacement
        new_node.children[i] = erase_impl(node.children[i], replacement)
        recalc_weight(new_node)
        return new_node
      else
        -- TODO proper algo
        table.remove(new_node.here, i)
        recalc_weight(new_node)
        return new_node
      end
    end
    if here.sampleable_persistent_set_idx < e.sampleable_persistent_set_idx then
      right_of = i
    end
  end
  
  local child = node.children[right_of+1]
  local sub_result = erase_impl(child, e)
  local new_children = shallow_copy(node.children)
  local new_here = shallow_copy(node.here)
  local new_node = {here=new_here,children=new_children}
  new_children[right_of+1] = sub_result
  recalc_weight(new_node)
  return new_node
end

local sample_impl
sample_impl = function(node)
  local choice = math.random() * node.total_weight
  for i,here in ipairs(node.here) do
    if node.children then
      choice = choice - node.children[i].total_weight
      if choice < 0 then return sample_impl(node.children[i]) end
    end
    choice = choice - here.weight
    if choice < 0 then return here end
  end
  if node.children then
    return sample_impl(node.children[#node.children])
  else
    return node.here[#node.here]
  end
end

heaviest_impl = function(node)
  local best
  local best_weight = -math.huge
  for i,here in ipairs(node.here) do
    if here.weight > best_weight then
      best_weight = here.weight
      best = here
    end
  end
  if node.children then
    for i,here in ipairs(node.children) do
      if here.heaviest > best_weight then
        best_weight = here.heaviest
        best = here
      end
    end
  end
  if not best then err_msg("no best?! "..inspect_impl(node)) end
  if best.weight then return best end
  return heaviest_impl(best)
end
  
local next_index = 1
local sampleable_set = function(root, persistent)
  local values = function()
    local stack
    local advance
    local climb_both
    local climb_down
    advance = function()
      if stack.node.children then
        if stack.node.children[stack.which_here+1] then
          stack = {
            parent = stack,
            node = stack.node.children[stack.which_here+1],
            which_here = 0,
          }
          return climb_down()
        end
      else
        stack.which_here = stack.which_here + 1
        local result = stack.node.here[stack.which_here]
        if result then return result end
      end
      return climb_both()
    end
    climb_both = function()
      stack = stack.parent
      if not stack then return end
      
      stack.which_here = stack.which_here + 1
      local result = stack.node.here[stack.which_here]
      if result then return result end
      return climb_both()
    end
    climb_down = function()
      while stack.node.children do
        stack = {
          parent = stack,
          node = stack.node.children[1],
          which_here = 0,
        }
      end
      return advance()
    end
    return profile_func("sps_iter", function()
      if not stack then
        if not root then return end
        stack = {
          node = root,
          which_here = 0,
        }
      end
      return advance()
    end)
  end
  return {
    insert = profile_func("sps_insert", function(e)
--       err_msg("before")
--       for v in values() do err_msg(v.sampleable_persistent_set_idx) end
      assert (e.weight)
      if not e.sampleable_persistent_set_idx then
        e.sampleable_persistent_set_idx = next_index
        next_index = next_index + 1
      end
--       err_msg("inserting")
--       err_msg(e.sampleable_persistent_set_idx)
      local new_root
      if not root then
        new_root = {here={e}}
        if not persistent then
          assert(e.sampleable_persistent_set_node == nil)
          e.sampleable_persistent_set_node = new_root
        end
        recalc_weight(new_root)
      else
        local sub_result = insert_impl(root, e, persistent)
        if sub_result[2] then
          new_root = {here={sub_result[2]},children={sub_result[1],sub_result[3]}}
          if not persistent then
            assert(sub_result[2].sampleable_persistent_set_node == sub_result[1])
            sub_result[2].sampleable_persistent_set_node = new_root
            sub_result[1].parent = new_root
            sub_result[3].parent = new_root
          end
          recalc_weight(new_root)
        else
          new_root = sub_result[1]
        end
      end
      --err_msg(inspect(new_root))
      if persistent then
        local result = sampleable_persistent_set(new_root, persistent)
--       err_msg("after")
--       for v in result.values() do err_msg(v.sampleable_persistent_set_idx) end
        return result
      else
        root = new_root
      end
      e.sampleable_persistent_set_old_weight = e.weight
    end),
    erase = profile_func("sps_erase", function(e)
--       err_msg("before")
--       for v in values() do err_msg(v.sampleable_persistent_set_idx) end
--       err_msg("erasing")
--       err_msg(e.sampleable_persistent_set_idx)
      local new_root = erase_impl(root, e, persistent)
      local result = sampleable_persistent_set(new_root)
--       err_msg("after")
--       for v in result.values() do err_msg(v.sampleable_persistent_set_idx) end
      return result
    end),
    sample = profile_func("sps_sample", function() return root and sample_impl(root) end),
    heaviest = profile_func("sps_heaviest", function() return root and heaviest_impl(root) end),
    values = values,
    inspect = function() return inspect_impl(root) end,
    update_member_weight = profile_func("sps_update_member_weight", function(e)
      assert(not persistent)
      update_member_weight(e)
    end),
  }
end
sampleable_persistent_set = function(root)
  return sampleable_set(root, true)
end
sampleable_mutable_set = function(root)
  return sampleable_set(root, false)
end
end -- do sampleable_persistent_set_impl

local find_reach = function(x1,y1,cost_func,maximum,zoc_side,state)
  local result = {}
  local frontier = priority_queue(function(hex) return -hex.cost end)
  local found_hexes = {}
  local reach_hex = function(x,y,cost)
    if not (maximum and (cost > maximum)) then
      local sunit
      local zocd = false
      if zoc_side then
        sunit = get_sunit(state,x,y)
        if cost > 0 then
          for x2,y2 in helper.adjacent_tiles(x, y) do
            local sunit2 = get_sunit(state,x2,y2)
            if sunit2 and wesnoth.is_enemy(zoc_side, sunit2.side) then -- TODO units without zoc
              zocd = true
            end
          end
        end
      end
      if (not zoc_side) or (not sunit) then table.insert(result, {x=x,y=y,cost=zocd and maximum or cost}) end
      if ((not zoc_side) or (not sunit) or (not wesnoth.is_enemy(zoc_side, sunit.side))) and not zocd then frontier.insert({x=x,y=y,cost=cost}) end
    end
  end
  local find_hex = function(x,y,old_cost)
    local idx = x..","..y
    if not found_hexes[idx] then
      found_hexes[idx] = true
      if old_cost then
        local cost = 1
        if cost_func then cost = cost_func(x,y,old_cost) end
        if cost then reach_hex(x,y,old_cost + cost) end
      else
        reach_hex(x,y,0)
      end
    end
  end
  find_hex(x1,y1)
  while frontier.top() do
    local start = frontier.pop()
    for x,y in helper.adjacent_tiles(start.x, start.y) do
      find_hex(x,y,start.cost)
    end
  end
  return result
end
find_reach = profile_func("find_reach", find_reach)

local find_unit_reach = function(state,x1,y1,sunit)
  local cost = function(x,y)
    return wesnoth.unit_movement_cost(sunit.wunit, get_terrain(state, x, y))
  end
  return find_reach(x1,y1, cost, sunit.moves, sunit.side, state)
end
find_unit_reach = profile_func("find_unit_reach", find_unit_reach)

local serialize_move = function(move)
  return move.type..","..(move.src and (move.src.x..","..move.src.y..",") or "")..(move.dst and (move.dst.x..","..move.dst.y..",") or "")..(move.weapon and (move.weapon..",") or "")..(move.unit_type and (move.unit_type..",") or "")
end

local random_move = function(node)
  local w,h = wesnoth.get_map_size()
  local units = node.sides[node.whose_turn].units
  local init_move = function(move)
    move.evaluation_sum = 0
    move.times_tried = 0
    move.before = node
    move.serialized = serialize_move(move)
    return move
  end
  local make_move = function(move)
    init_move(move)
    node.move_choices.insert(move)
    local whole_turn_move = node.turn.move_choices[move.serialized]
    if not whole_turn_move then
      whole_turn_move = {
        evaluation_sum = 0,
        times_tried = 0,
        instances = {move},
      }
      node.turn.move_choices[move.serialized] = whole_turn_move
    else
      table.insert(whole_turn_move.instances, move)
    end
  end
  if not node.move_choices then node.move_choices = sampleable_mutable_set(); make_move({type="end_turn", weight = 0.01}) end
  local proc_unit = function()
    local sunit = units.sample()
    if sunit then
      if get_sunit(node,sunit.x,sunit.y) ~= sunit then err_msg("uhh") end
      if not sunit.choices_determined_for[node] then
        if sunit.attacks_left > 0 then
          for x2,y2 in helper.adjacent_tiles(sunit.x,sunit.y) do
            local sunit2 = get_sunit(node,x2,y2)
            if sunit2 and wesnoth.is_enemy(sunit2.side, sunit.side) then
              for i in ipairs(sunit.attacks) do
                make_move({
                  type="attack",
                  src = {x=sunit.x,y=sunit.y},
                  dst = {x=x2,y=y2},
                  weapon = i,
                  weight = 10,
                })
              end
            end
          end
        end
        if sunit.moves > 0 then
          local reach = find_unit_reach(node, sunit.x, sunit.y, sunit)
          for i,hex in ipairs(reach) do
            make_move({
              type="move",
              src = {x=sunit.x,y=sunit.y},
              dst = hex,
              weight = (hex.cost == sunit.moves) and 1 or 0.1,
            })
          end
        end
        if sunit.wunit.canrecruit and wesnoth.get_terrain_info(get_terrain(node, sunit.x, sunit.y)).keep then
          for i,recruit_dst in ipairs(find_reach(sunit.x,sunit.y,function(x, y)
                    return wesnoth.get_terrain_info(get_terrain(node, x, y)).castle and 1 or nil
                  end)) do
            if not get_sunit(node, recruit_dst.x, recruit_dst.y) then
              for i,recruit_type in ipairs(wesnoth.sides[node.whose_turn].recruit) do
                if wesnoth.unit_types[recruit_type].cost <= node.sides[node.whose_turn].gold then
                  make_move({ type = "recruit", dst = recruit_dst, unit_type = recruit_type, weight = 100 })
                end
              end
              for i,recruit_type in ipairs(sunit.wunit.extra_recruit) do
                if wesnoth.unit_types[recruit_type].cost <= node.sides[node.whose_turn].gold then
                  make_move({ type = "recruit", dst = recruit_dst, unit_type = recruit_type, weight = 100 })
                end
              end
            end
          end
        end
        sunit.choices_determined_for[node] = true
      end
    end
  end
  
  local result = node.move_choices.heaviest()
  for i=1,3 do if result.type == "end_turn" then proc_unit(); result = node.move_choices.heaviest() end end
  for v in node.move_choices.values() do
    if v.weight > result.weight then
      err_msg("not heaviest?! "..node.move_choices.inspect())
    end
  end
  --generate_move_result(node, result)
  if result.before ~= node then err_msg("uhh2"..debug.traceback()) end
  return result
end
random_move = profile_func("random_move", random_move)

local round_damage = function(base,mult,div)
  local unrounded = base * mult / div
  if unrounded < base then return math.max(1, math.floor((base*mult*2 + div) / (div*2)))
  else                     return math.max(1, math.ceil ((base*mult*2 - div) / (div*2))) end
end

local generate_move_result_by_type = {
  end_turn = function(state, move)
    local new_state = hpss_copy(state)
    new_state.turn = {move_choices = {}}
    new_state.whose_turn = new_state.whose_turn + 1
    if new_state.whose_turn > #wesnoth.sides then
      new_state.whose_turn = 1
    end
    local new_side = hpss_index(hpss_index(new_state, "sides"), new_state.whose_turn)
    -- TODO: income, healing
    new_side.units = sampleable_persistent_set()
    for sunit in new_side.units.values() do
      local new_sunit = shallow_copy(sunit)
      new_sunit.moves = new_sunit.wunit.max_moves
      new_sunit.attacks_left = 1
      set_unit(new_state, new_sunit)
    end
    return new_state
  end,
  move = function(state, move)
    local new_state = hpss_copy(state)
    local sunit = shallow_copy(get_sunit(new_state, move.src.x, move.src.y))
    sunit.moves = sunit.moves - move.dst.cost
    sunit.x = move.dst.x
    sunit.y = move.dst.y
    remove_map_unit(new_state, move.src.x, move.src.y)
    set_unit(new_state, sunit)
    return new_state
  end,
  attack = function(state, move)
    local new_state = hpss_copy(state)
    local a = {x=move.src.x, y=move.src.y}
    local d = {x=move.dst.x, y=move.dst.y}
    a.opp = d; d.opp = a
    for i,c in ipairs({a,d}) do
      c.sunit = shallow_copy(get_sunit(new_state, c.x, c.y))
      c.defense = wesnoth.unit_defense(c.sunit.wunit, get_terrain(new_state, c.x, c.y))
    end
    a.sunit.moves = 0
    a.sunit.attacks_left = a.sunit.attacks_left - 1
    a.sunit.weight = 0
    a.weapon = a.sunit.attacks[move.weapon]
    for i,w in ipairs(d.sunit.attacks) do
      if w.range == a.weapon.range then d.weapon = w end --TODO...
    end
    for i,c in ipairs({a,d}) do
      c.swings = 0
      if c.weapon then
        c.swings = c.weapon.number
        c.damage = round_damage(c.weapon.damage, c.opp.sunit.resistance[c.weapon.type], 100)
      end
    end
    local over = false
    local swing = function(h,v)
      if math.random(1,100) <= v.defense then
        v.sunit.hitpoints = v.sunit.hitpoints - h.weapon.damage
        h.swings = h.swings - 1
        if v.sunit.hitpoints <= 0 then v.sunit = nil; over = true end
      end
    end
    while a.swings > 0 and d.swings > 0 and not over do
      if a.swings > 0 and not over then swing(a,d) end
      if d.swings > 0 and not over then swing(d,a) end
    end
    for i,c in ipairs({a,d}) do
      c.swings = c.weapon and c.weapon.number or 0
      if c.sunit then set_unit(new_state, c.sunit)
      else remove_unit(new_state, c.x, c.y) end
    end
    return new_state
  end,
  recruit = function(state, move)
    local new_state = hpss_copy(state)
    local sunit = load_recruit(move.unit_type, new_state.whose_turn, move.dst.x, move.dst.y)
    -- TODO: traits
    local new_side = hpss_index(hpss_index(new_state, "sides"), new_state.whose_turn)
    new_side.gold = new_side.gold - wesnoth.unit_types[move.unit_type].cost
    set_unit(new_state, sunit)
    --assert (evaluate(new_state)[new_state.whose_turn] > evaluate(state)[new_state.whose_turn])
    return new_state
  end,
}
generate_move_result = function(state, move)
  local new_state = generate_move_result_by_type[move.type](state, move)
  new_state.total_moves = new_state.total_moves + 1
  new_state.last_move = move
  new_state.move_choices = nil
  new_state.times_entered = nil
  return new_state
end
generate_move_result = profile_func("generate_move_result", generate_move_result)

--[[
local playout_result_from = function(node)
  local results_func = function()
    local sides_with_leaders = {}
    local w,h = wesnoth.get_map_size()
    local units_map = node.units_map
    for x=1,w do
      local col = units_map[x]
      for y=1,h do
        local sunit = col[y]
        if sunit and sunit.wunit.canrecruit then
          sides_with_leaders[sunit.side] = true
        end
      end
    end
    for side1 in pairs(sides_with_leaders) do
      for side2 in pairs(sides_with_leaders) do
        if wesnoth.is_enemy(side1, side2) then return nil end
      end
    end
    return {winners = sides_with_leaders}
  end
  
  local num_moves = 0
  local before_playout = timestamp()
--   err_msg("begin playout")
  while true do
    local move = random_move(node)
--     err_msg(serialize_move(move))
    node = generate_move_result(node, move)
    local results = results_func()
    num_moves = num_moves + 1
    local now = timestamp()
    if results then
--       err_msg("playout succeeded")
      return results
    end
    if num_moves > 2000 then
      err_msg("playout took more than 2000 moves, aborting")
      return {winners={}}
    end
    if (now - before_playout) > 50 then
      err_msg("playout took more than 50ms, aborting")
      return {winners={}}
    end
  end
end
playout_result_from = profile_func("playout_result_from", playout_result_from)]]

evaluate = function(node)
  local result = {}
  local sides = {}
  local units_map = node.units_map
  
  for side,info in ipairs(wesnoth.sides) do
    sides[side] = {
      gold = info.gold,
      strength_sum = 0,
      leader_strength_sum = 0,
    }
  end
--   err_msg(node.last_move.serialized)
  for x,col in ipairs(units_map) do
    for y,sunit in pairs(col) do if type(y) == "number" then
--       err_msg(sunit.tunit.type)
      sides[sunit.side].strength_sum = sides[sunit.side].strength_sum + (
        sunit.tunit.cost * (1+(sunit.hitpoints/sunit.wunit.max_hitpoints))
      )
      if sunit.wunit.canrecruit then
        sides[sunit.side].leader_strength_sum = sides[sunit.side].leader_strength_sum + (
          1+(sunit.hitpoints/sunit.wunit.max_hitpoints)
        )
      end
    end end
  end
  for side1,info1 in ipairs(sides) do
    local enemy_ally = {}
    for a,b in ipairs({true,false}) do
      enemy_ally[b] = {
        strength_sum = 0,
        leader_strength_sum = 0,
      }
    end
    for side2,info2 in ipairs(sides) do
      local enemy = wesnoth.is_enemy(side1, side2)
      enemy_ally[enemy].strength_sum = enemy_ally[enemy].strength_sum + info2.strength_sum
      enemy_ally[enemy].leader_strength_sum = enemy_ally[enemy].leader_strength_sum + info2.leader_strength_sum
    end
    for a,b in ipairs({true,false}) do
      enemy_ally[b].strength_agg = enemy_ally[b].leader_strength_sum * (1-(1/(1+(enemy_ally[b].strength_sum/100))))
    end
    result[side1] = enemy_ally[false].strength_agg - enemy_ally[true].strength_agg
  end
--   err_msg(inspect(sides))
--   err_msg(node.total_moves.." "..inspect(result))
  return result
end


local mc_iteration = function(mc_tree)
  local node = mc_tree
  node.times_entered = (node.times_entered or 0) + 1
  while true do
--     err_msg((node == mc_tree) and "a" or "b")
    local move = random_move(node)
    move.times_tried = move.times_tried + 1
    if move_is_deterministic(move) then
      if not move.after then
        move.after = generate_move_result(node, move)
      end
      node = move.after
    else
      if not move.after then
        move.after = {}
      end
      -- TODO: for recruits, stop after generating all trait combos
      if (not move.after[1]) or ((#move.after) < math.log(move.times_tried)) then
        table.insert(move.after, generate_move_result(node, move))
      end
      node = move.after[math.random(1, #move.after)]
    end
    node.times_entered = (node.times_entered or 0) + 1
--     err_msg((node.move_choices) and "c" or "d")
--     if node.move_choices then for v in node.move_choices.values() do if v.before ~= node then err_msg("uhh4") end end end
    if move.times_tried == 1 then break end
  end
  local evaluations = evaluate(node)
  
  while true do
    local move = node.last_move
    if not move then break end
    local prev_node = move.before
    move.evaluation_sum = move.evaluation_sum + evaluations[prev_node.whose_turn]
    local whole_turn_move = prev_node.turn.move_choices[move.serialized]
    whole_turn_move.evaluation_sum = whole_turn_move.evaluation_sum + evaluations[prev_node.whose_turn]
    whole_turn_move.times_tried = whole_turn_move.times_tried + 1
    for i,cousin in ipairs(whole_turn_move.instances) do
      local wt_factor = (1/(1+(cousin.times_tried/10)))
      if cousin.times_tried > 0 then
        cousin.weight = (
               wt_factor *(whole_turn_move.evaluation_sum/whole_turn_move.times_tried)
          + (1-wt_factor)*(         cousin.evaluation_sum/         cousin.times_tried)
          + math.sqrt(2*math.log(cousin.before.times_entered)/cousin.times_tried)
        )
      else
        cousin.weight = (
          (whole_turn_move.evaluation_sum/whole_turn_move.times_tried)
          + math.sqrt(2*math.log(cousin.before.times_entered)/1)
        )
      end
      cousin.before.move_choices.update_member_weight(cousin)
    end
    node = prev_node
  end
end
mc_iteration = profile_func("mc_iteration", mc_iteration)

local do_move_by_type = {
  move = function(move) builtin_ai_stuff.move(move.src.x, move.src.y, move.dst.x, move.dst.y) end,
  attack = function(move) builtin_ai_stuff.attack(move.src.x, move.src.y, move.dst.x, move.dst.y, move.weapon-1) end,
  recruit = function(move) builtin_ai_stuff.recruit(move.unit_type, move.dst.x, move.dst.y) end,
  end_turn = function() return true end,
}

local best_move = function(node)
  local best
  local best_quality
  for move in node.move_choices.values() do
    local quality = move.times_tried
    err_msg(move.serialized..": "..quality.." ("..(move.evaluation_sum/move.times_tried)..", "..move.weight..")")
    if (not best) or (quality > best_quality) then
      best = move
      best_quality = quality
    end
  end
  return best
end

local do_move = function(move)
  return not do_move_by_type[move.type](move)
end

local calculate_and_do_one_move = function()
  local before_loading = timestamp()
  local state = load_game_state()
  local after_loading = timestamp()
  local mc_tree = state
  local mc_iterations = 0
  while true do
    mc_iteration(mc_tree)
    --wesnoth.fire("redraw")
    mc_iterations = mc_iterations + 1
    local after_mc_iteration = timestamp()
    if (mc_iterations > 5000) or ((after_mc_iteration - after_loading) > 2000) then
      err_msg(""..(after_loading-before_loading).."ms loading, "..(after_mc_iteration - after_loading).."ms doing "..mc_iterations.." iterations.")
      break
    end
  end
  --dump_tree(mc_tree, 3)
  return do_move(best_move(mc_tree))
end

local our_ai = { }
function our_ai:do_moves()
  while calculate_and_do_one_move() do end
  dump_profiling()
end

return our_ai
--! ==============================================================
>>
  [/engine]
  [stage]
    engine="lua"
    code="(...):do_moves()"
  [/stage]
[/ai]

