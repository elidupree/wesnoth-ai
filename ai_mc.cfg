[ai]
  version=1071034
  [engine]
    name="lua"
    code= <<
--! ==============================================================
helper = wesnoth.require("lua/helper.lua")

local builtin_ai_stuff = ...

local state_with_unit = function(state, x, y, sunit)
  local new_state = shallow_copy(state)
  local col = shallow_copy(state.map[x])
  local loc = shallow_copy(col[y])
  loc.sunit = sunit
  col[y] = loc
  new_state.map[x] = col
  return new_state
end

local generate_move_result_by_type = {
  end_turn = function(state, move)
    local new_state = shallow_copy(state)
    new_state.whose_turn = new_state.whose_turn + 1
    if new_state.whose_turn > #wesnoth.sides then
      new_state.whose_turn = 1
    end
    return new_state
  end,
  move = function(state, move)
    local sunit = get_sunit(state, move.src.x, move.src.y)
    return state_with_unit(state_with_unit(state, move.src.x, move.src.y, nil), move.dst.x, move.dst.y, sunit)
  end,
  attack = function(state, move)
    local a = {sunit=shallow_copy(get_sunit(state, move.src.x, move.src.y))}
    local d = {sunit=shallow_copy(get_sunit(state, move.dst.x, move.dst.y))}
    a.weapon = a.sunit.attacks[move.weapon]
    for i,w in ipairs(d.sunit.attacks) do
      if w.range == a_weapon.range then d.weapon = w end
    end
    local a.swings = a.weapon.number
    local d.swings = d.weapon.number
    local over = false
    swing = function(h,v)
      v.sunit.hitpoints = v.sunit.hitpoints - h.weapon.damage
      h.swings = h.swings - 1
      if v.sunit.hitpoints <= 0 then v.sunit = nil; over = true end
    end
    while a.swings > 0 and d.swings > 0 and not over do
      if a.swings > 0 then swing(a,d) end
      if d.swings > 0 then swing(d,a) end
    end
    return state_with_unit(state_with_unit(state, move.src.x, move.src.y, a.sunit), move.dst.x, move.dst.y, d.sunit)
  end,
  recruit = function(state, move)
    local sunit = 
    return state_with_unit(state, move.dst.x, move.dst.y, sunit)
  end,
}
local generate_move_result = function(state, move)
  local new_state = generate_move_result_by_type[move.type](move)
  new_state.last_move = move
  return new_state
end


local deterministic_move_types = {move=true,end_turn=true}
local move_is_deterministic = function(move)
  return deterministic_move_types[move] or false
end

local mc_iteration = function(mc_tree)
  local node = mc_tree
  while do
    local move = random_move(node)
    move.times_tried = move.times_tried + 1
    if move_is_deterministic(move) then
      if not move.after then
        table.insert(move.after, generate_move_result(node, move))
      end
      node = move.after
    else
      -- TODO: for recruits, stop after generating all trait combos
      if (#move.after) < math.log(move.times_tried) then
        table.insert(move.after, generate_move_result(node, move))
      end
      node = move.after[math.random(1, #move.after)]
    end
  end
  local result = playout_result_from(node)
  
  while true do
    local move = node.last_move
    if not move then break end
    local prev_node = move.before
    move.priority = ((move.priority*(move.times_tried-1)) + (result.winners[prev_node.whose_turn] and 1 or 0)) / move.times_tried
    node = prev_node
  end
end

local do_move_by_type = {
  move = function(move) builtin_ai_stuff.move(move.src.x, move.src.y, move.dst.x, move.dst.y) end,
  attack = function(move) builtin_ai_stuff.attack(move.src.x, move.src.y, move.dst.x, move.dst.y, move.weapon-1) end,
  recruit = function(move) builtin_ai_stuff.recruit(move.unit_type, move.dst.x, move.dst.y) end,
  end_turn = function() return true end,
}
local do_move = function(move)
  return not do_move_by_type[move.type](move)
end

local timestamp = function()
  if wesnoth.get_time_stamp then return wesnoth.get_time_stamp() end
  wesnoth.fire("set_variable", {name="LUA_TEMP", time="stamp"})
  local result = wesnoth.get_variable("LUA_TEMP")
  wesnoth.set_variable("LUA_TEMP")
  return result
end

local calculate_and_do_one_move = function()
  local before_loading = timestamp()
  local state = load_game_state()
  local after_loading = timestamp()
  local mc_tree = state
  local mc_iterations = 0
  while true do
    mc_iteration(mc_tree)
    mc_iterations = mc_iterations + 1
    local after_mc_iteration = timestamp()
    if (mc_iterations > 5000) or ((after_mc_iteration - after_loading) > 5000) then
      wesnoth.message(""..(after_loading-before_loading).."ms loading, "..(after_mc_iteration - after_loading).."ms doing "..mc_iterations.." iterations (playouts).")
      break
    end
  end
  return do_move(best_move(mc_tree))
end

local our_ai = { }
function our_ai:do_moves()
  while calculate_and_do_one_move() do end
end

return our_ai
--! ==============================================================
>>
  [/engine]
  [stage]
    engine="lua"
    code="(...):do_moves()"
  [/stage]
[/ai]

