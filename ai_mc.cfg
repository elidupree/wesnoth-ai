[ai]
  version=1071034
  [engine]
    name="lua"
    code= <<--mc_ai.cfg
--! ==============================================================
local helper = wesnoth.require("lua/helper.lua")

local builtin_ai_stuff = ...

local err_msg = function(msg)
  wesnoth.fire("wml_message", { logger="err", message=msg })
end

local timestamp = function()
  if wesnoth.get_time_stamp then return wesnoth.get_time_stamp() end
  wesnoth.fire("set_variable", {name="LUA_TEMP", time="stamp"})
  local result = wesnoth.get_variable("LUA_TEMP")
  wesnoth.set_variable("LUA_TEMP")
  return result
end

local shallow_copy = function(input)
  if type(input) ~= "table" then return input end
  local result = {}
  for k,v in pairs(input) do result[k]=v end
  return result
end

local state_with_unit = function(state, x, y, sunit)
  local new_state = shallow_copy(state)
  local map = shallow_copy(state.map)
  local col = shallow_copy(map[x])
  local loc = shallow_copy(col[y])
  loc.sunit = sunit
  col[y] = loc
  map[x] = col
  new_state.map = map
  return new_state
end

local get_sunit = function(state, x, y)
  return state.map[x][y].sunit
end

local get_terrain = function(state, x, y)
  return state.map[x][y].terrain
end

local load_unit = function(wunit)
  local tunit = wunit.__cfg
  local attacks = {}
  local sunit = {
    wunit = wunit,
    hitpoints = wunit.hitpoints,
    moves = wunit.moves,
    attacks_left = wunit.attacks_left,
    attacks = attacks,
  }
  for attack in helper.child_range(tunit, "attack") do
    table.insert(attacks, attack)
  end
  return sunit
end

local load_game_state = function()
  local map = {}
  local sides = {}
  local state = {
    whose_turn = wesnoth.current.side,
    map = map,
    sides = sides,
    moves = {},
  }
  
  local w,h = wesnoth.get_map_size()
  
  for x=1,w do
    local col = {}
    map[x] = col
    
    for y=1,h do
      local loc = {
        terrain = wesnoth.get_terrain(x,y)
      }
      col[y] = loc
      
      local wunit = wesnoth.get_unit(x,y)
      if wunit then
        loc.sunit = load_unit(wunit)
      end
    end
  end
  
  for side,info in ipairs(wesnoth.sides) do
    sides[side] = { gold=info.gold }
  end
  
  return state
end

local priority_queue = function(priority_func)
  local function heap_insert(h,v,priority)
    h.size = h.size + 1
    if h.top_priority < priority then
      local temp = h.top
      local tempp = h.top_priority
      h.top = v
      h.top_priority = priority
      v = temp
      priority = tempp
    end
        if not h.child1 then h.child1 = {size=1,top=v,top_priority=priority}
    elseif not h.child2 then h.child2 = {size=1,top=v,top_priority=priority}
    else heap_insert((h.child1.size <= h.child2.size) and h.child1 or h.child2,v,priority) end
  end
  local function heap_pop(h)
    h.size = h.size - 1
    local child
        if not h.child1 then child = "child2"
    elseif not h.child2 then child = "child1"
    else child = (h.child1.top_priority > h.child2.top_priority) and "child1" or "child2" end
    h.top=h[child].top; h.top_priority=h[child].top_priority
    if h[child].size == 1 then h[child] = nil
    else heap_pop(h[child]) end
  end
  local heap
  return {
    insert = function(v,priority)
      priority = priority or (priority_func and priority_func(v) or v)
        if not heap then heap = {size=1,top=v,top_priority=priority}
      else heap_insert(heap, v, priority) end
    end,
    top = function() return heap and heap.top end,
    pop = function()
      if heap then
        local result = heap.top
        if heap.size == 1 then heap = nil
        else heap_pop(heap) end
        return result
      end
    end,
  }
end

local find_reach = function(x1,y1,cost_func,maximum,zoc_side,state)
  local result = {}
  local frontier = priority_queue(function(hex) return -hex.cost end)
  local found_hexes = {}
  local reach_hex = function(x,y,cost)
    if not (maximum and (cost > maximum)) then
      local sunit
      if zoc_side then sunit = get_sunit(state,x,y) end
      if (not zoc_side) or (not sunit) then table.insert(result, {x=x,y=y,cost=cost}) end
      if (not zoc_side) or (not sunit) or (not wesnoth.is_enemy(zoc_side, sunit.wunit.side)) then frontier.insert({x=x,y=y,cost=cost}) end
    end
  end
  local find_hex = function(x,y,old_cost)
    local idx = x..","..y
    if not found_hexes[idx] then
      found_hexes[idx] = true
      if old_cost then
        local cost = 1
        if cost_func then cost = cost_func(x,y,old_cost) end
        if cost then reach_hex(x,y,old_cost + cost) end
      else
        reach_hex(x,y,0)
      end
    end
  end
  find_hex(x1,y1)
  while frontier.top() do
    local start = frontier.pop()
    local stopped = false
    if zoc_side and (start.cost > 0) then
      for x,y in helper.adjacent_tiles(start.x, start.y) do
        local sunit = get_sunit(state,x,y)
        if sunit and wesnoth.is_enemy(zoc_side, sunit.wunit.side) then -- TODO units without zoc
          stopped = true
        end
      end
    end
    if not stopped then
      for x,y in helper.adjacent_tiles(start.x, start.y) do
        find_hex(x,y,start.cost)
      end
    end
  end
  return result
end

local find_unit_reach = function(state,x1,y1,sunit)
  local cost = function(x,y)
    return wesnoth.unit_movement_cost(sunit.wunit, get_terrain(state, x, y))
  end
  return find_reach(x1,y1, cost, sunit.moves, sunit.wunit.side, state)
end

local serialize_move = function(move)
  return move.type..","..(move.src and (move.src.x..","..move.src.y..",") or "")..(move.dst and (move.dst.x..","..move.dst.y..",") or "")..(move.weapon and (move.weapon..",") or "")..(move.unit_type and (move.unit_type..",") or "")
end

local random_move = function(node)
  local choices = {{type="end_turn"}}
  local w,h = wesnoth.get_map_size()
  local map = node.map
  for x=1,w do
    local col = map[x]
    for y=1,h do
      local loc = col[y]
      local sunit = loc.sunit
      if sunit and sunit.wunit.side == node.whose_turn then
        if sunit.attacks_left > 0 then
          for x2,y2 in helper.adjacent_tiles(x,y) do
            local sunit2 = get_sunit(node,x2,y2)
            if sunit2 and wesnoth.is_enemy(sunit2.wunit.side, sunit.wunit.side) then
              for i in ipairs(sunit.attacks) do
                table.insert(choices, {
                  type="attack",
                  src = {x=x,y=y},
                  dst = {x=x2,y=y2},
                  weapon = i,
                })
              end
            end
          end
        end
        if sunit.moves > 0 then
          local reach = find_unit_reach(node, x,y,sunit)
          for i,hex in ipairs(reach) do
            table.insert(choices, {
              type="move",
              src = {x=x,y=y},
              dst = {x=hex.x,y=hex.y},
            })
          end
        end
        if sunit.wunit.canrecruit and wesnoth.get_terrain_info(loc.terrain).keep then
          for i,recruit_dst in ipairs(find_reach(x,y,function(x, y)
                    return wesnoth.get_terrain_info(get_terrain(node, x, y)).castle and 1 or nil
                  end)) do
            if not get_sunit(node, recruit_dst.x, recruit_dst.y) then
              for i,recruit_type in ipairs(wesnoth.sides[node.whose_turn].recruit) do
                if wesnoth.unit_types[recruit_type].cost <= node.sides[node.whose_turn].gold then
                  table.insert(choices, { type = "recruit", dst = recruit_dst, unit_type = recruit_type })
                end
              end
              for i,recruit_type in ipairs(sunit.wunit.extra_recruit) do
                if wesnoth.unit_types[recruit_type].cost <= sim.gold then
                  table.insert(choices, { type = "recruit", dst = recruit_dst, unit_type = recruit_type })
                end
              end
            end
          end
        end
      end
    end
  end
  local move = choices[math.random(1,#choices)]
  move.priority = 0
  move.times_tried = 0
  move.before = node
  local serial = serialize_move(move)
  local already = node.moves[serial]
  if already then
    return already
  else
    node.moves[serial] = move
    return move
  end
end

local best_move = function(node)
  local best
  for k,move in pairs(node.moves) do
    if (not best) or (move.priority > best.priority) then
      best = move
    end
  end
  return best
end

local generate_move_result_by_type = {
  end_turn = function(state, move)
    local new_state = shallow_copy(state)
    new_state.whose_turn = new_state.whose_turn + 1
    if new_state.whose_turn > #wesnoth.sides then
      new_state.whose_turn = 1
    end
    return new_state
  end,
  move = function(state, move)
    local sunit = get_sunit(state, move.src.x, move.src.y)
    return state_with_unit(state_with_unit(state, move.src.x, move.src.y, nil), move.dst.x, move.dst.y, sunit)
  end,
  attack = function(state, move)
    local a = {x=move.src.x, y=move.src.y}
    local d = {x=move.dst.x, y=move.dst.y}
    for i,c in ipairs({a,d}) do
      c.sunit = shallow_copy(get_sunit(state, c.x, c.y))
      c.defense = wesnoth.unit_defense(c.sunit.wunit, get_terrain(state, c.x, c.y))
    end
    a.weapon = a.sunit.attacks[move.weapon]
    for i,w in ipairs(d.sunit.attacks) do
      if w.range == a.weapon.range then d.weapon = w end --TODO...
    end
    for i,c in ipairs({a,d}) do
      c.swings = c.weapon and c.weapon.number or 0
    end
    local over = false
    swing = function(h,v)
      if math.random(1,100) > v.defense then
        v.sunit.hitpoints = v.sunit.hitpoints - h.weapon.damage
        h.swings = h.swings - 1
        if v.sunit.hitpoints <= 0 then v.sunit = nil; over = true end
      end
    end
    while a.swings > 0 and d.swings > 0 and not over do
      if a.swings > 0 and not over then swing(a,d) end
      if d.swings > 0 and not over then swing(d,a) end
    end
    return state_with_unit(state_with_unit(state, move.src.x, move.src.y, a.sunit), move.dst.x, move.dst.y, d.sunit)
  end,
  recruit = function(state, move)
    local new_state = shallow_copy(state)
    local sunit = load_unit(wesnoth.create_unit({
      x=move.dst.x,
      y=move.dst.y,
      side=state.whose_turn,
      type=move.unit_type,
      generate_name=false,
      random_traits=false,
      random_gender=false,
    }))
    new_state.sides = shallow_copy(new_state.sides)
    new_state.sides[state.whose_turn] = shallow_copy(new_state.sides[state.whose_turn])
    new_state.sides[state.whose_turn].gold = new_state.sides[state.whose_turn].gold - wesnoth.unit_types[move.unit_type].cost
    -- TODO: traits
    return state_with_unit(new_state, move.dst.x, move.dst.y, sunit)
  end,
}
local generate_move_result = function(state, move)
  local new_state = generate_move_result_by_type[move.type](state, move)
  new_state.last_move = move
  new_state.moves = {}
  return new_state
end

local deterministic_move_types = {move=true,end_turn=true}
local move_is_deterministic = function(move)
  return deterministic_move_types[move] or false
end

local playout_result_from = function(node)
  local results_func = function()
    local sides_with_leaders = {}
    local w,h = wesnoth.get_map_size()
    local map = node.map
    for x=1,w do
      local col = map[x]
      for y=1,h do
        local loc = col[y]
        local sunit = loc.sunit
        if sunit and sunit.wunit.canrecruit then
          sides_with_leaders[sunit.wunit.side] = true
        end
      end
    end
    for side1 in pairs(sides_with_leaders) do
      for side2 in pairs(sides_with_leaders) do
        if wesnoth.is_enemy(side1, side2) then return nil end
      end
    end
    return {winners = sides_with_leaders}
  end
  
  local num_moves = 0
  local before_playout = timestamp()
  while true do
    local move = random_move(node)
    node = generate_move_result(node, move)
    local results = results_func()
    num_moves = num_moves + 1
    local now = timestamp()
    if results then return results end
    if num_moves > 2000 then
      err_msg("playout took more than 2000 moves, aborting")
      return {winners={}}
    end
    if (now - before_playout) > 10 then
      err_msg("playout took more than 10ms, aborting")
      return {winners={}}
    end
  end
end

local mc_iteration = function(mc_tree)
  local node = mc_tree
  while true do
    local move = random_move(node)
    move.times_tried = move.times_tried + 1
    if move_is_deterministic(move) then
      if not move.after then
        move.after = generate_move_result(node, move)
      end
      node = move.after
    else
      if not move.after then
        move.after = {}
      end
      -- TODO: for recruits, stop after generating all trait combos
      if (not move.after[1]) or ((#move.after) < math.log(move.times_tried)) then
        table.insert(move.after, generate_move_result(node, move))
      end
      node = move.after[math.random(1, #move.after)]
    end
    if move.times_tried == 1 then break end
  end
  local result = playout_result_from(node)
  
  while true do
    local move = node.last_move
    if not move then break end
    local prev_node = move.before
    move.priority = ((move.priority*(move.times_tried-1)) + (result.winners[prev_node.whose_turn] and 1 or 0)) / move.times_tried
    node = prev_node
  end
end

local do_move_by_type = {
  move = function(move) builtin_ai_stuff.move(move.src.x, move.src.y, move.dst.x, move.dst.y) end,
  attack = function(move) builtin_ai_stuff.attack(move.src.x, move.src.y, move.dst.x, move.dst.y, move.weapon-1) end,
  recruit = function(move) builtin_ai_stuff.recruit(move.unit_type, move.dst.x, move.dst.y) end,
  end_turn = function() return true end,
}
local do_move = function(move)
  return not do_move_by_type[move.type](move)
end

local calculate_and_do_one_move = function()
  local before_loading = timestamp()
  local state = load_game_state()
  local after_loading = timestamp()
  local mc_tree = state
  local mc_iterations = 0
  while true do
    mc_iteration(mc_tree)
    mc_iterations = mc_iterations + 1
    local after_mc_iteration = timestamp()
    if (mc_iterations > 5000) or ((after_mc_iteration - after_loading) > 5000) then
      err_msg(""..(after_loading-before_loading).."ms loading, "..(after_mc_iteration - after_loading).."ms doing "..mc_iterations.." iterations (playouts).")
      break
    end
  end
  return do_move(best_move(mc_tree))
end

local our_ai = { }
function our_ai:do_moves()
  while calculate_and_do_one_move() do end
end

return our_ai
--! ==============================================================
>>
  [/engine]
  [stage]
    engine="lua"
    code="(...):do_moves()"
  [/stage]
[/ai]

